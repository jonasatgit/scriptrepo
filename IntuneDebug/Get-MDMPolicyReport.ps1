
<#
.SYNOPSIS
    Script to create html report of Intune policies from MDM Diagnostics Report XML file.
 
.DESCRIPTION
    #************************************************************************************************************
    # Disclaimer
    #
    # This sample script is not supported under any Microsoft standard support program or service. This sample
    # script is provided AS IS without warranty of any kind. Microsoft further disclaims all implied warranties
    # including, without limitation, any implied warranties of merchantability or of fitness for a particular
    # purpose. The entire risk arising out of the use or performance of this sample script and documentation
    # remains with you. In no event shall Microsoft, its authors, or anyone else involved in the creation,
    # production, or delivery of this script be liable for any damages whatsoever (including, without limitation,
    # damages for loss of business profits, business interruption, loss of business information, or other
    # pecuniary loss) arising out of the use of or inability to use this sample script or documentation, even
    # if Microsoft has been advised of the possibility of such damages.
    #
    #************************************************************************************************************

    This script generates a HTML report of Intune policies from the MDM Diagnostics Report XML, HTML and AppWorkload.log files

    The script can be run locally on a device to generate a new report or it can be run with the MDMDiagReportPath parameter to use an existing MDM Diagnostics export folder.
    The report includes information about Intune script policies, LAPS settings, firewall settings, and more.

.VERSION
    4.0.1

.AUTHOR
    Jonas Ohmsen

.LINK
    https://aka.ms/IntuneDebug

.PARAMETER MDMDiagReportPath
    Path to the MDM Diagnostics export folder. 
    The folder should contain the MDMDiagReport.xml file, the MDMDiagReport.html file, and the IntuneManagementExtension AppWorkload.log files.
    If not provided, a new report of the system running the script on will be generated.

.PARAMETER CleanUpDays
    Number of days to keep the MDM Diagnostics report folders. Default is 1 day.
    Folders older than this number of days will be removed from the MDM Diagnostics folder.
    This parameter only applies to the report data generated by this script.

#>

[CmdletBinding()]
param 
(
    [Parameter(Mandatory = $false)]
    [string]$MDMDiagReportPath,

    [Parameter(Mandatory = $false)]
    [int]$CleanUpDays = 1
)



#region Get-ValidDateTime
function Get-ValidDateTime
{
    param 
    (
        [string]$DateTimeString
    )

    $knownFormats = @(
        'M-d-yyyy HH:mm:ss.fffffff',
        'M-dd-yyyy HH:mm:ss.fffffff',
        'MM-d-yyyy HH:mm:ss.fffffff',
        'MM-dd-yyyy HH:mm:ss.fffffff',
        'yyyy-MM-dd HH:mm:ss.fffffff',
        'dd.MM.yyyy HH:mm:ss.fffffff'
        'M-d-yyyy HH:mm:ss',
        'M-dd-yyyy HH:mm:ss',
        'MM-d-yyyy HH:mm:ss',
        'MM-dd-yyyy HH:mm:ss',
        'yyyy-MM-dd HH:mm:ss',
        'dd.MM.yyyy HH:mm:ss'
    )

    foreach ($format in $knownFormats) 
    {
        try 
        {
            return [datetime]::ParseExact($DateTimeString, $format, $null)
        } 
        catch 
        {
            continue
        }
    }
}
#endregion


#region Get-IntuneScriptPolicies
Function Get-IntuneScriptPolicies
{

    param
    (
        [string]$LogPath
    )

    if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))
    {
        if ([string]::IsNullOrEmpty($LogPath))
        {
            # The message does only makes sense if the script is run locally without the MDMDiagReportPath parameter
            # NOT YET
            #Write-Host "To get more Intune script details run the script with administrative permissions" -ForegroundColor Yellow 
        }
    }
    else 
    {
        if ([string]::IsNullOrEmpty($LogPath))
        {
            # Status per user ID
            # Many more entries due to older polices. Admin permissions required
            #'HKLM:\SOFTWARE\Microsoft\IntuneManagementExtension\SideCarPolicies\Scripts'
        }
    }

    if ([string]::IsNullOrEmpty($LogPath))
    {
        # Default log path for intune script logs
        $LogPath = "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\HealthScripts*.log"
    } 
    
    # creating hash with script id and shedule from log file
    $pattern = '\[HS\] inspect daily schedule for policy (?<policyID>.*?), (?<policyScheduleUTC>.*?), (?<policyScheduleInterval>.*?), (?<policyScheduleTime>.*?)(?=\]LOG\])'

    $scriptSSchedulePolicyResult = Get-ChildItem $LogPath | Sort-Object -Property LastWriteTime -Descending | select-string -Pattern $pattern

    $policyScheduleHash = @{}
    foreach ($scriptPolicy in $scriptSSchedulePolicyResult)
    {
        # Files sortted by LastWriteTime, so we can take the first one and have the latest policy schedule and skip the duplicates
        $policyID = $scriptPolicy.Matches.groups[1].value
        # Check if the policyID already exists in the hash
        if ($policyScheduleHash.ContainsKey($policyID)) 
        {
            # If it exists, skip to the next iteration
            continue
        }
        
        $policyScheduleUTC = ($scriptPolicy.Matches.groups[2].value) -replace 'UTC = ', ''
        $policyScheduleInterval = ($scriptPolicy.Matches.groups[3].value) -replace 'Interval = ', ''
        $policyScheduleTime = ($scriptPolicy.Matches.groups[4].value) -replace 'Time = ', ''

        # check if the policyID already exists in the hash and in the settings are identical
        $policyScheduleHash[$policyID] = [pscustomobject][ordered]@{
            #PolicyID = $policyID
            ScheduleUTC = $policyScheduleUTC
            ScheduleInterval = $policyScheduleInterval
            ScheduleTime = $policyScheduleTime
        }
    }

    # Getting script policies 
    $pattern = '\[HS\] new result = (?<policyString>\{"PolicyId.*?\})(?=\]LOG\])'
    $scriptPolicyResult = Get-ChildItem -Path $LogPath | Sort-Object -Property LastWriteTime -Descending | select-string -Pattern $pattern

    $outList = [System.Collections.Generic.List[pscustomobject]]::new()
    $policyCheckHash = @{}
    foreach ($scriptPolicy in $scriptPolicyResult)
    {
        # Files sortted by LastWriteTime, so we can take the first one and have the latest policy schedule and skip the duplicates
        $policyString = $scriptPolicy.Matches.groups[1].value

        # Convert the JSON string to a PowerShell object
        $policyData = $policyString | ConvertFrom-Json -ErrorAction SilentlyContinue

        if ($null -eq $policyData) 
        {
            Write-Verbose "Failed to convert policy data from JSON: $policyString"
            continue
        }

        if ($policyCheckHash.ContainsKey($policyData.PolicyId)) 
        {
            # If the policy ID already exists in the hash, skip to the next iteration
            continue
        }

        # Check if the policyID already exists in the hash
        if ($policyScheduleHash.ContainsKey($policyData.PolicyId)) 
        {
            # If it exists, add the schedule data to the policy data
            $policyData | Add-Member -MemberType NoteProperty -Name 'Schedule' -Value ($policyScheduleHash[$policyData.PolicyId])
        }
        else 
        {
            # If it does not exist, create a new property for the schedule with null values
            $policyData | Add-Member -MemberType NoteProperty -Name 'Schedule' -Value ([pscustomobject]@{
                #PolicyID = $null
                ScheduleUTC = $null
                ScheduleInterval = $null
                ScheduleTime = $null
            })
        }

        # Convert the RunAsAccount value to a more readable format
        Switch($policyData.RunAsAccount) 
        {
            1 { $policyData.RunAsAccount = '1 = System' }
            2 { $policyData.RunAsAccount = '2 = User' }
            Default { $policyData.RunAsAccount = "$($policyData.RunAsAccount) = Unknown" }
        }

        $policyCheckHash[$policyData.PolicyId] = $true
        # Output the policy data
        $outList.Add($policyData)
    }

    return $outList
}
#endregion


#region Test-IfStringIsValidBase64 
function Test-IfStringIsValidBase64 
{
    param([string]$Text)

    # Check format: only valid Base64 characters and optional padding
    if ($Text -notmatch '^[A-Za-z0-9+/]*={0,2}$') 
    {
        return $false
    }

    # Length must be a multiple of 4
    if ($Text.Length % 4 -ne 0) 
    {
        return $false
    }

    # Length must be at least 16 cahrs long
    if ($Text.Length -lt 16) 
    {
        return $false
    }

    try 
    {
        [Convert]::FromBase64String($Text) | Out-Null
        return $true
    } 
    catch 
    {
        return $false
    }
}
#endregion


#region Get-IntuneOfficeInstallParams
Function Get-IntuneOfficeInstallParams
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [string]$ID
    )

    $basePath = "HKLM:SOFTWARE\Microsoft\OfficeCSP\$ID"

    try{$propertyValue = Get-ItemPropertyValue -Path $basePath -Name '(Default)' -ErrorAction SilentlyContinue }catch{}

    return $propertyValue
}
#endregion

#region Get-MDMFirewallSetting
Function Get-MDMFirewallSetting
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        [string]$Topic,
        [Parameter(Mandatory = $true)]
        [string]$SettingName
    )

    $basePath = "HKLM:SYSTEM\ControlSet001\Services\SharedAccess\Parameters\FirewallPolicy\Mdm"
    $topicPath = Join-Path -Path $basePath -ChildPath $Topic

    $propertyValue = $null
    if (-Not (Test-Path -Path $topicPath)) 
    {
        #Write-Error "The specified topic path does not exist: $topicPath"
        return $null
    }
    else 
    {
        try{$propertyValue = Get-ItemPropertyValue -Path $topicPath -Name $SettingName -ErrorAction SilentlyContinue }catch{}
    }

    return $propertyValue
}
#endregion


#region Get-CertificateDetailsByThumbprint
function Get-CertificateDetailsByThumbprint 
{
    param 
    (
        [Parameter(Mandatory = $true)]
        [string[]]$Thumbprints
    )

    [array]$certList = Get-ChildItem Cert:\LocalMachine -Recurse 

    $outList = [System.Collections.Generic.List[pscustomobject]]::new()
    foreach ($item in $thumbprints)
    {
        [array]$tmpCert = $certList | Where-Object { $_.Thumbprint -eq $item }
        if ($tmpCert) 
        {

            [array]$tmpStoreName = $tmpCert.pspath -replace '.*?Certificate::[^\\]+\\([^\\]+)\\.*', '$1' -replace 'CA', 'Intermediate CA' -replace 'Root', 'Root CA'

            $outList.Add([pscustomobject]@{
                Info = "Found in $($tmpStoreName.count) store(s)"
                Store = ($tmpStoreName -join ', ')
                Issuer = $tmpCert[0].Issuer -replace '^CN='
                IssuedTo = ($tmpCert[0].Subject -replace '^.*CN=([^,]+),.*$', '$1' -replace '^CN=')
                Thumbprint = $item
                ValidFrom = $tmpCert[0].NotBefore
                ValidTo = $tmpCert[0].NotAfter
                ExpireDays = try{[math]::Round(($tmpCert[0].NotAfter - (Get-Date)).TotalDays, 2)} catch { 'N/A' }
            })
        }
        else 
        {
            $outList.Add([pscustomobject]@{
                Info = 'Not found'
                Store = ''
                Issuer = ''
                IssuedTo = ''
                Thumbprint = $item
                ValidFrom = ''
                ValidTo = ''
                ExpireDays = ''
            })
        }
    }
    return $outList
}
#endregion


#region Get-IntunePoliyLAPSData
Function Get-IntunePoliyLAPSData
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        $MDMData
    )

    # https://learn.microsoft.com/en-us/windows/client-management/mdm/laps-csp
    $BackupDirectoryMap = @{
        0 = "0 = Disabled (password won't be backed up)" # Default
        1 = "1 = Backup the password to Microsoft Entra ID only"
        2 = "2 = Backup the password to Active Directory only"
    }

    $PasswordComplexityMap = @{
        1 = "1 = Large letters."
        2 = "2 = Large letters + small letters."
        3 = "3 = Large letters + small letters + numbers."
        4 = "4 = Large letters + small letters + numbers + special characters." # Default
        5 = "5 = Large letters + small letters + numbers + special characters (improved readability)."
        6 = "6 = Passphrase (long words)."
        7 = "7 = Passphrase (short words)."
        8 = "8 = Passphrase (short words with unique prefixes)."
    }

    $PostAuthenticationActionMap = @{
        1  = "1 = Reset password: upon expiry of the grace period, the managed account password will be reset."
        3  = "3 = Reset the password and logoff the managed account: upon expiry of the grace period, the managed account password will be reset and any interactive logon sessions using the managed account will be terminated." # Default
        5  = "5 = Reset the password and reboot: upon expiry of the grace period, the managed account password will be reset and the managed device will be immediately rebooted."
        11 = "11 = Reset the password, logoff the managed account, and terminate any remaining processes: upon expiration of the grace period, the managed account password is reset, any interactive logon sessions using the managed account are logged off, and any remaining processes are terminated."
    }

    $AutomaticAccountManagementTargetMap = @{
        0 = "0 = Automatically manage the built-in Administrator account"
        1 = "1 = Automatically manage a new custom account"
    }

    $AutomaticAccountManagementEnableAccountMap = @{
        0 = "0 = Disable the automatically managed account"
        1 = "1 = Enable the automatically managed account"
    }

    $AutomaticAccountManagementRandomizeNameMap = @{
        0 = "0 = Don't randomize the name of the automatically managed account"
        1 = "1 = Randomize the name of the automatically managed account"
    }

    # Initialize the output object
    $lapsOutObj = [pscustomobject][ordered]@{
        PolicyScope = 'LAPS'
        BackupDirectory = $null
        PasswordAgeDays = $null
        AutomaticAccountManagementEnabled = $null
        AutomaticAccountManagementNameOrPrefix = $null
        AutomaticAccountManagementEnableAccount = $null
        AutomaticAccountManagementTarget = $null
        AutomaticAccountManagementRandomizeName = $null
        PasswordComplexity = $null
        PostAuthenticationActions = $null
        PasswordLength = $null
        PostAuthenticationResetDelay = $null
        Local_LastAccountRidUpdated = $null
        Local_DSRMMode = $null
        Local_LastManagedAccountRid = $null
        Local_LastManagedAccountNameOrPrefix = $null
        Local_LastManagedAccountRandomizeName = $null
        Local_LastPasswordUpdateTime = $null
        Local_AzurePasswordExpiryTime = $null
        Local_PostAuthResetDeadline = $null
        Local_PostAuthResetAuthenticationTime = $null
        Local_PostAuthResetAccountSid = $null
        Local_PostAuthResetRetryCount = $null
        Local_PostAuthActions = $null
    }

    $LAPSData = $MDMData.MDMEnterpriseDiagnosticsReport.LAPS

    if (-NOT [string]::IsNullOrEmpty($LAPSData.Laps_CSP_Policy)) 
    {
        $lapsOutObj.BackupDirectory = try{$BackupDirectoryMap[[int]$LAPSData.Laps_CSP_Policy.BackupDirectory]}catch {$LAPSData.Laps_CSP_Policy.BackupDirectory}
        $lapsOutObj.PasswordAgeDays = $LAPSData.Laps_CSP_Policy.PasswordAgeDays
        $lapsOutObj.AutomaticAccountManagementEnabled = if($LAPSData.Laps_CSP_Policy.AutomaticAccountManagementEnabled -eq 1){"True"}else{"False"}
        $lapsOutObj.AutomaticAccountManagementNameOrPrefix = $LAPSData.Laps_CSP_Policy.AutomaticAccountManagementNameOrPrefix
        $lapsOutObj.AutomaticAccountManagementEnableAccount = try{$AutomaticAccountManagementEnableAccountMap[[int]$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementEnableAccount]}catch {$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementEnableAccount}
        $lapsOutObj.AutomaticAccountManagementTarget = try{$AutomaticAccountManagementTargetMap[[int]$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementTarget]}catch {$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementTarget}
        $lapsOutObj.AutomaticAccountManagementRandomizeName = try{$AutomaticAccountManagementRandomizeNameMap[[int]$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementRandomizeName]}catch {$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementRandomizeName}
        $lapsOutObj.PasswordComplexity = try{$PasswordComplexityMap[[int]$LAPSData.Laps_CSP_Policy.PasswordComplexity]}catch {$LAPSData.Laps_CSP_Policy.PasswordComplexity}
        $lapsOutObj.PostAuthenticationActions = try{$PostAuthenticationActionMap[[int]$LAPSData.Laps_CSP_Policy.PostAuthenticationActions]}catch {$LAPSData.Laps_CSP_Policy.PostAuthenticationActions}
        $lapsOutObj.PasswordLength = $LAPSData.Laps_CSP_Policy.PasswordLength
        $lapsOutObj.PostAuthenticationResetDelay = $LAPSData.Laps_CSP_Policy.PostAuthenticationResetDelay
       
        if (-NOT [string]::IsNullOrEmpty($LAPSData.Laps_Local_State)) 
        {
            $lapsOutObj.Local_LastAccountRidUpdated = $LAPSData.Laps_Local_State.LastAccountRidUpdated
            $lapsOutObj.Local_DSRMMode = $LAPSData.Laps_Local_State.DSRMMode
            $lapsOutObj.Local_LastManagedAccountRid = $LAPSData.Laps_Local_State.LastManagedAccountRid
            $lapsOutObj.Local_LastManagedAccountNameOrPrefix = $LAPSData.Laps_Local_State.LastManagedAccountNameOrPrefix
            $lapsOutObj.Local_LastManagedAccountRandomizeName = $LAPSData.Laps_Local_State.LastManagedAccountRandomizeName
            $lapsOutObj.Local_LastPasswordUpdateTime = try{Convert-FileTimeToDateTime -FileTime $LAPSData.Laps_Local_State.LastPasswordUpdateTime} catch {$LAPSData.Laps_Local_State.LastPasswordUpdateTime}
            $lapsOutObj.Local_AzurePasswordExpiryTime = try{Convert-FileTimeToDateTime -FileTime $LAPSData.Laps_Local_State.AzurePasswordExpiryTime} catch {$LAPSData.Laps_Local_State.AzurePasswordExpiryTime}
            $lapsOutObj.Local_PostAuthResetDeadline = try{Convert-FileTimeToDateTime -FileTime $LAPSData.Laps_Local_State.PostAuthResetDeadline} catch {$LAPSData.Laps_Local_State.PostAuthResetDeadline}
            $lapsOutObj.Local_PostAuthResetAuthenticationTime = try{Convert-FileTimeToDateTime -FileTime $LAPSData.Laps_Local_State.PostAuthResetAuthenticationTime} catch {$LAPSData.Laps_Local_State.PostAuthResetAuthenticationTime}
            $lapsOutObj.Local_PostAuthResetAccountSid = $LAPSData.Laps_Local_State.PostAuthResetAccountSid
            $lapsOutObj.Local_PostAuthResetRetryCount = $LAPSData.Laps_Local_State.PostAuthResetRetryCount
            $lapsOutObj.Local_PostAuthActions = $LAPSData.Laps_Local_State.PostAuthActions
        }

        return $lapsOutObj   
    }
}
#endregion


#region ConvertTo-HTMLTableFromArray
Function ConvertTo-HTMLTableFromArray 
{
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [array]$InputList,
        [Parameter(Mandatory = $false)]
        [string]$TableType 
    )


    $htmlOutput = ""

    for ($i = 0; $i -lt $InputList.Count; $i++) 
    {
        $item = $InputList[$i]
        $htmlOutput += "<table class='nested-table'>"

        foreach ($prop in $item.PSObject.Properties) 
        {

            if ($TableType -eq 'ScriptBody' -and $prop.Name -eq 'ScriptBody') 
            {
                # If the property is ScriptBody, decode it and display it in a <pre> tag
                # This is to handle the case where the script body is base64 encoded
                # and we want to display it as text in the HTML report

                $htmlOutput += "<tr>"
                $htmlOutput += "<td colspan='2'>$($prop.Name)</td>"
                $htmlOutput += "</tr>"

                try 
                {
                    $htmlOutput += "<tr>"
                    $decodedBytes = [System.Convert]::FromBase64String($InputList.ScriptBody)
                    $decodedString = [System.Text.Encoding]::UTF8.GetString($decodedBytes)
                  
                    $htmlOutput += "<td colspan='2'>"
                    $htmlOutput += "   <div class='script-container'>"
                    $htmlOutput += "        <button class='toggle-button-inner-script' onclick='toggleScript(this)'>Hide</button>"
                    $htmlOutput += "        <button class='toggle-button-inner-script' onclick='copyScript(this)'>Copy</button>"
                    $htmlOutput += "        <pre class='script-body'>$decodedString</pre>"
                    $htmlOutput += "    </div>"
                    $htmlOutput += "</td>"
                    $htmlOutput += "<tr>"
                } 
                catch 
                {
                    $htmlOutput += "<td>$(Invoke-EscapeHtmlText -Text ($prop.Value.ToString()))</td>"
                }                
            } 
            else 
            {
                $htmlOutput += "<tr>"
                $htmlOutput += "<td>$($prop.Name)</td>"

                if ($prop.Value -is [System.Management.Automation.PSObject] -or $prop.Value -is [hashtable]) 
                {
                    # Recursively call the same function for nested objects
                    $nestedHtml = ConvertTo-HTMLTableFromArray -InputList @($prop.Value)
                    $htmlOutput += "<td>$nestedHtml</td>"
                } 
                else 
                {
                    $htmlOutput += "<td>$($prop.Value)</td>"
                }

                $htmlOutput += "</tr>"
            }
        }

        $htmlOutput += "</table>"

        # Add <hr> only if this is not the last item
        if ($i -lt $InputList.Count - 1) 
        {
            $htmlOutput += "<hr style='border: 0; border-top: 1px solid #ccc; margin: 20px 0;'>"
        }
    }

    return $htmlOutput
}
#endregion

#region Get-HTMLTableFromData
Function Get-HTMLTableFromData 
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $false)]
        [object]$InputData,
        [Parameter(Mandatory = $false)]
        [ValidateSet('ScriptBody')]
        [string]$TableType
    )

    $propertyValue = ''
    try 
    {
        # lets find out what type of data we are dealing with
        $propType = $InputData.GetType() | Select-Object -Property Name -ExpandProperty Name
    }
    catch 
    {
        $propType = 'Unknown' # Default to string if we cannot determine the type
    }

    switch ($propType) 
    {
        'PSCustomObject' 
        { 
            $propertyValue = ConvertTo-HTMLTableFromArray -InputList ($InputData) -TableType $TableType
        }

        'String'
        {
            # Some properties we should be able to convert to json and make them easier to read in that format
            try 
            {
                $propertyValue = ConvertTo-HTMLTableFromArray -InputList ($InputData | ConvertFrom-Json -ErrorAction Stop) -TableType $TableType
            }
            catch 
            {
                $propertyValue = $InputData
            }   
        }
        Default {$propertyValue = $InputData}
    }    
    
    return $propertyValue
}
#endregion


#region ConvertTo-HTMLListFromArray
Function ConvertTo-HTMLListFromArray
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [array]$InputList      
    )

    $maxLength = ($InputList | ForEach-Object {
        $_.PSObject.Properties | ForEach-Object { $_.Name.Length }
        } | Measure-Object -Maximum).Maximum

    $outString = ''
    foreach ($item in $InputList)
    {
        foreach ($prop in $item.PSObject.Properties) 
        {
            $dots = '.' * ($maxLength - $prop.Name.Length + 2)  # +2 for spacing

            $outString += '{0}{1}: {2}<br>' -f $prop.Name, $dots, $($prop.Value)
        }
        $outString += "<br>"  # Extra line between objects
    }

    return $outString
}
#endregion


#region Invoke-IntuneReportDataCleanup
Function Invoke-IntuneReportDataCleanup
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $false)]
        [int]$CleanUpDays = 1
    )

    $MDMDiagFolder = "$env:PUBLIC\Documents\MDMDiagnostics"

    if (-NOT (Test-Path -Path $MDMDiagFolder)) 
    {
        return # nothing to cleanup
    }
    else 
    {
        # Get all folders with names in the format of 'yyyy-MM-dd_HH-mm-ss'
        [array]$folderList = Get-ChildItem -Path $MDMDiagFolder -Directory | Where-Object { $_.Name -match '^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}$' }

        # now cleanup the folders that are older than the specified number of days based on their name
        foreach ($folder in $folderList) 
        {
            # Get the folder creation time
            $folderCreationTime = [datetime]::ParseExact($folder.Name, 'yyyy-MM-dd_HH-mm-ss', $null)

            # Check if the folder is older than the specified number of days
            if ($folderCreationTime -lt (Get-Date).AddDays(-$CleanUpDays)) 
            {
                # Remove the folder and its contents
                Write-Host "Removing old policy report folder: $($folder.FullName)"
                Remove-Item -Path $folder.FullName -Recurse -Force -ErrorAction SilentlyContinue
            }
        }
    }
}
#endregion


#region Get-MSIProductCodesWithNames
function Get-MSIProductCodesWithNames 
{
    $results = @()

    $registryPaths = @(
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    )

    foreach ($path in $registryPaths) 
    {
        if (Test-Path $path) {
            Get-ChildItem -Path $path | ForEach-Object {
                $key = $_
                $productCode = $key.PSChildName

                if ($productCode -match '^\{[0-9A-F\-]{36}\}$') 
                {
                    $props = Get-ItemProperty -Path $key.PSPath -ErrorAction SilentlyContinue
                    $displayName = $props.DisplayName

                    $results += [PSCustomObject]@{
                        ProductCode = $productCode
                        Name        = $displayName
                    }

                }
            }
        }
    }
    return $results
}
#endregion


#region Get-IntunePolicyDataFromXML
Function Get-IntunePolicyDataFromXML
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $false)]
        [string]$MDMDiagReportPath
    )

    # If no path is provided, generate a new report
    if ([string]::IsNullOrEmpty($MDMDiagReportPath)) 
    {
        $MDMDiagFolder = "$env:PUBLIC\Documents\MDMDiagnostics\$(Get-date -Format 'yyyy-MM-dd_HH-mm-ss')"

        if (-NOT (Test-Path -Path $MDMDiagFolder)) 
        {
            New-Item -Path $MDMDiagFolder -ItemType Directory | Out-Null
        }

        $MDMDiagReportXmlPath = '{0}\MDMDiagReport.xml' -f $MDMDiagFolder

        Start-Process MdmDiagnosticsTool.exe -Wait -ArgumentList "-out `"$MDMDiagFolder`"" -NoNewWindow -ErrorAction Stop

        [xml]$xmlFile = Get-Content -Path $MDMDiagReportXmlPath -Raw -ErrorAction Stop
    }
    else 
    {
        if (-Not (Test-Path -Path $MDMDiagReportPath)) 
        {
            Write-Error "The specified MDM Diagnostics path does not exist: `"$MDMDiagReportPath`""
            return
        }

        $MDMDiagReportXmlPath = '{0}\MDMDiagReport.xml' -f $MDMDiagReportPath

        if (-Not (Test-Path -Path $MDMDiagReportXmlPath))
        {
            Write-Error "The specified MDM Diagnostics Report XML file does not exist: `"$MDMDiagReportXmlPath`""
            return
        }
        [xml]$xmlFile = Get-Content -Path $MDMDiagReportXmlPath -Raw -ErrorAction Stop
    }

    $outObj = [pscustomobject]@{
        XMlFileData = $xmlFile
        FileFullName = $MDMDiagReportXmlPath
    }
    return $outObj
}
#endregion


#region Get-IntunePolicySystemInfo
# Extract system information from the MDM Diagnostics Report
Function Get-IntunePolicySystemInfo
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        [string]$HtmlReportPath
    )

    if (-not (Test-Path -Path $HtmlReportPath)) 
    {
        # Lets thest for a different file name
        # This might be the case if the report was generated with the settings app or the MDM Diagnostics Tool with differnt parameters
        # MDMDiagHTMLReport.html
        $HtmlReportPath = $HtmlReportPath -replace 'MDMDiagReport\.html', 'MDMDiagHTMLReport.html'
    }

    $htmlFile = Get-Content -Path $HtmlReportPath -Raw -ErrorAction SilentlyContinue

    $tablePattern = '<table[^>]*id="(?:DeviceInfoTable|ConnectionInfoTable)"[^>]*>(.*?)<\/table>'
    $tableMatches = [regex]::Matches($htmlFile, $tablePattern, 'Singleline')

    $properties = @{} 
    
    $outObj = [pscustomobject][ordered]@{
                    DeviceName = $null
                    Organization = $null
                    Edition = $null
                    OSBuild = $null
                    Processor = $null
                    #InstalledRAM = $null
                    SystemType = $null
                    #ManagedBy = $null
                    LastSync = $null
                    ManagementServerAddress = $null
                    ExchangeID = $null
                    ActiveSID = $null
                    ActiveAccount = $null
                    UserToken = $null
                    PolicyScope = 'DeviceInfo'
                }

    foreach($tableMatch in $tableMatches)
    {
        $rowPattern = '"LabelColumn">(?<Label>.*?)</td><td.*?>(?<Value>.*?)</td>'
        $valueResults = [regex]::Matches($tableMatch, $rowPattern)

        
        foreach($item in $valueResults)
        {
            $labelObj = $item.Groups | Where-Object -Property Name -eq 'Label'
            $valueObj = $item.Groups | Where-Object -Property Name -eq 'Value'

            $properties[$labelObj.Value] = $valueObj.Value
        }
    }

    $tmpObj = [PSCustomObject]$properties
    try 
    {
        $outObj.DeviceName = $tmpObj.'PC name'
        $outObj.Organization = $tmpObj.'Organization'
        $outObj.Edition = $tmpObj.'Edition'
        $outObj.OSBuild = $tmpObj.'OS Build'
        $outObj.Processor = $tmpObj.'Processor'
        #$outObj.InstalledRAM = $tmpObj.'Installed RAM'
        $outObj.SystemType = $tmpObj.'System Type'
        #$outObj.ManagedBy = $tmpObj.'Managed By'
        $outObj.LastSync = $tmpObj.'Last Sync'
        $outObj.ManagementServerAddress = $tmpObj.'Management Server Address'
        $outObj.ExchangeID = $tmpObj.'Exchange ID'
        $outObj.ActiveSID = $tmpObj.'Active SID'
        $outObj.ActiveAccount = $tmpObj.'Active Account'
        $outObj.UserToken = $tmpObj.'User Token'

        if ($outObj.OSBuild -gt 10.0.19045) 
        {
            $outObj.Edition = $outObj.Edition -replace 'Windows 10', 'Windows 11'
        }

        # lets remove the word unknown from the systemtype if it is present
        $outObj.SystemType = ($outObj.SystemType -replace 'Unknown', '') -replace '^\s+',''     
    }
    catch {}

    return $outObj
}
#endregion


#region Get-IntuneDeviceAndUserPolicies
Function Get-IntuneDeviceAndUserPolicies
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        $MDMData
    )

    $userInfoHash = Get-LocalUserInfo

    $outObj = [System.Collections.Generic.List[pscustomobject]]::new()
    # Iterate through each ConfigSource item in the XML
    foreach ($item in $MDMData.MDMEnterpriseDiagnosticsReport.PolicyManager.ConfigSource)
    {
        $enrollmentID = $item.EnrollmentId
        
        foreach ($PolicyScope in $item.PolicyScope)
        {
            $PolicyScopeName = $PolicyScope.PolicyScope

            foreach ($area in $PolicyScope.Area)
            {
                if ($area.PolicyAreaName -ieq 'knobs')
                {
                    # Skip the 'knobs' area
                    continue
                }

                # Define the properties we are interested in 
                [array]$propertyList = $area | Get-Member | 
                                            Where-Object {$_.MemberType -eq 'Property'} | 
                                            Select-Object -Property Name | 
                                            Where-Object {$_.Name -notlike '*_LastWrite' -and $_.Name -ne 'PolicyAreaName'}

                try{$enrollmentProvider = $script:enrollmentProviderIDs[$enrollmentID]}catch{}                
                if([string]::IsNullOrEmpty($enrollmentProvider))
                {
                    $enrollmentProvider = 'Unknown'
                }

                try{$userName = $userInfoHash[$PolicyScopeName]}catch{}
                if([string]::IsNullOrEmpty($userName))
                {
                    $userName = 'Unknown'
                }

                $tmpObj = [pscustomobject]@{
                                EnrollmentId = $enrollmentID
                                EnrollmentProvider = $enrollmentProvider
                                PolicyScope  =  $PolicyScopeName
                                PolicyScopeDisplay = if ($PolicyScopeName -eq 'Device') { $PolicyScopeName } else { $userName }
                                PolicyAreaName = $area.PolicyAreaName
                                SettingsCount = $propertyList.Count
                                Settings = ""
                            }

                $settingsList = [System.Collections.Generic.List[pscustomobject]]::new()
                foreach ($property in $propertyList)
                {
                    # Adding metadata for the property
                    $metadataInfo = Get-IntunePolicyMetadata -MDMData $MDMData -PolicyAreaName $area.PolicyAreaName -PolicyName $property.Name
                    if ($area.PolicyAreaName -ieq 'knobs')
                    {
                        $winningProvider = "Not set"
                    }
                    else 
                    {
                        $currentPolicyInfo = Get-IntunePolicyCurrentData -PolicyScope $PolicyScopeName -PolicyAreaName $area.PolicyAreaName -PolicyName $property.Name -MDMData $MDMData
                        if ($null -eq $currentPolicyInfo)
                        {
                            $winningProvider = "Not set"    
                        }
                        else 
                        {
                            $winningProvider = $currentPolicyInfo | Select-Object -ExpandProperty "$($property.Name)_WinningProvider"
                        }
                    }                    

                    $settingsList.Add([pscustomobject][ordered]@{
                        Name = $property.Name
                        Value = $area.$($property.Name)
                        WinningProvider = $winningProvider
                        Metadata = $metadataInfo
                    })
                }

                $tmpObj.Settings = $settingsList   
                
                # Add the tmpObj to the $outObj
                $outObj.Add($tmpObj)
            }
        }
    }

    return $outObj
}
#endregion


#region Get-IntuneWin32AppPolicies
function Get-IntuneWin32AppPolicies
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $false)]
        [string]$LogPath
    )

    $statusList = [System.Collections.Generic.List[pscustomobject]]::new()

    # check if the script is running with administrative privileges
    if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))
    {
        if ([string]::IsNullOrEmpty($script:MDMDiagReportPathVariable))
        {
            # The message does only makes sense if the script is run locally without the MDMDiagReportPath parameter
            Write-Host "To get a more detailed Win32App report run the script with administrative permissions" -ForegroundColor Yellow
        }
    }
    else
    {
        [array]$win32AppStatusServiceReports = Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\IntuneManagementExtension\SideCarPolicies\StatusServiceReports"
        
        foreach ($report in $win32AppStatusServiceReports)
        {

            $identityID = $report.Name | Split-Path -Leaf -ErrorAction SilentlyContinue

            $assignedTo = if ($identityID -eq '00000000-0000-0000-0000-000000000000'){'💻 Device'}else{'👤 {0}' -f $identityID.ToString()}
            [array]$reportData = Get-ChildItem -Path $report.PSPath

            foreach ($dataItem in $reportData)
            {
                # adding some symbols
                $tmpApplicabilityCode = $dataItem.GetValue("ApplicabilityCode")
                if ($tmpApplicabilityCode -eq 'Applicable'){$tmpApplicabilityCode = '✅ Applicable'}else{$tmpApplicabilityCode = '❌ {0}' -f $tmpApplicabilityCode}
                
                $tmpStatus = $dataItem.GetValue("Status")
                if ($tmpStatus -eq 'Installed'){$tmpStatus = '✅ Installed'}else{$tmpStatus = '❌ {0}' -f $tmpStatus}

                $tmpObj = [pscustomobject][ordered]@{
                    #AssignedTo         = $assignedTo
                    Identity            = $assignedTo
                    AppId              = $dataItem.GetValue("AppId")
                    ApplicabilityCode  = $tmpApplicabilityCode
                    ApplicabilityCode2 = $dataItem.GetValue("ApplicabilityCode2")
                    CustomError        = $dataItem.GetValue("CustomError")
                    Required           = $dataItem.GetValue("Required")
                    Status             = $tmpStatus
                    Status2            = $dataItem.GetValue("Status2")
                    ErrorCode          = $dataItem.GetValue("ErrorCode")
                }

                $statusList.Add($tmpObj)            
            }
        }
    }
    

    if ([string]::IsNullOrEmpty($LogPath))
    {
        # Default log path for Win32 App Management logs
        $LogPath = "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\AppWorkload*.log"
    }       

    $logFiles = Get-ChildItem -Path $LogPath | Sort-Object -Property LastWriteTime -Descending

    # Corrected regex pattern for extracting the policy JSON
    $pattern = '<!\[LOG\[Get policies = (?<policy>\[\{.*?\}\])\]LOG\]!>'

    # Get all policies with regex pattern filter
    $lines = $logFiles | Select-String -Pattern $pattern

    if ($lines) 
    {
        $appPolicyList = [System.Collections.Generic.List[PSCustomObject]]::new()
        $boolErrorHappened = $false
        foreach ($line in $lines) 
        {
            # Extract date and time
            $Matches = $null
            if ($line.Line -match 'time="(?<time>.*?)" date="(?<date>.*?)"') 
            {
                $dateTimeString = '{0} {1}' -f ($Matches['date']), ($Matches['time'])
                # Parse the date and time to a DateTime object
                $dateTime = $null
                $dateTime = Get-ValidDateTime -DateTimeString $dateTimeString

                # If parsing fails, output a warning once. Every line might fail and we dont want 200 errors visible
                if ((-NOT $dateTime) -and (-not $boolErrorHappened))
                {
                    Write-Warning "Failed to parse date and time from file: $($line.Filename) and line: $($line.Line)"
                    $boolErrorHappened = $true
                    continue
                }            
            }

            # Extract and convert the policy JSON
            $Matches = $null
            if ($line.Line -match $pattern) 
            {
                $policyJson = $Matches['policy']
                try 
                {
                    $policyObject = $policyJson | ConvertFrom-Json -ErrorAction Stop

                    # add property
                    foreach ($app in $policyObject)
                    {
                        # Set to default value
                        $app | Add-Member -MemberType NoteProperty -Name 'AppState' -Value @()       
                    }

                    $appPolicyList.Add([PSCustomObject][ordered]@{
                        DateTime = $dateTime
                        PolicyCount = $policyObject.Count
                        Policy   = $policyObject
                    })
                } 
                catch 
                {
                    Write-Warning "Failed to parse JSON from line: $($line.Filename). Error: $_"
                }
            }
        }

        # Output the parsed policies
        $appList = $appPolicyList | Sort-Object -Property DateTime -Descending | Select-Object -First 1
    }


    # Now we have the appList with the latest policies, lets add the status information
    if ($statusList.count -gt 0)
    {
        foreach ($app in $appList.Policy)
        {
            [array]$appState = $statusList | Where-Object -Property 'AppID' -EQ ($app.Id) | Select-Object Identity, ApplicabilityCode, Required, Status, ErrorCode
            if ($appState.count -gt 0)
            {
                $app.AppState = $appState
            }
        }
    }

    return ($appList.Policy | Sort-Object -Property Name)
}
#endregion


#region Get-LocalUserInfo
function Get-LocalUserInfo 
{
    $userHashTable = @{}

    Get-ChildItem 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList' |
    ForEach-Object {
        $sid = $_.PSChildName
        try 
        {
            $profilePath = (Get-ItemProperty $_.PSPath).ProfileImagePath
            $username = Split-Path -Leaf $profilePath
            $userHashTable[$sid] = $username
        } catch {
            $userHashTable[$sid] = 'Unknown'
        }
    }

    return $userHashTable
}
#endregion


#region Get-IntuneResourcePolicies
function Get-IntuneResourcePolicies
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        $MDMData
    )


    $outList = [System.Collections.Generic.List[pscustomobject]]::new()
    foreach ($enrollment in $MDMData.MDMEnterpriseDiagnosticsReport.Resources.Enrollment)
    {
        $enrollmentID = $enrollment.enrollmentid

        foreach ($scope in $enrollment.Scope)
        {
            $resourceTarget = $scope.ResourceTarget
            #$scope.ChildNodes.'#Text'
            foreach ($resource in $scope.Resources.ChildNodes.'#Text')
            {
                # Setting $matches to null to avoid issues with previous matches
                $matches = $null
                if (($resource -match '^\d+$') -or ($resource -match '^default$'))
                {
                    continue
                }

                # Setting $matches to null to avoid issues with previous matches
                $matches = $null
                $tmpResourceType = 'Unknown'
                if ($resource -match "Vendor/[^/]+/([^/]+)") 
                {
                    $tmpResourceType = $matches[1]
                }

                $tmpCertObj = [pscustomobject]@{
                    CertStore = $null
                    Issuer = $null
                    IssuedTo = $null
                    Thumbprint = $null
                    ValidFrom = $null
                    ValidTo = $null
                    ExpireDays = $null
                }

                # running locally?
                $tmpSubject = ''
 
                $boolCertResource = $false
                switch -Regex ($resource) 
                {
                    'RootCATrustedCertificates\/Root' 
                    {
                        $certPath = "Cert:\{0}\Root\{1}"
                        $certStoreName = 'Root CA'
                        $boolCertResource = $true
                    }

                    'RootCATrustedCertificates\/CA'
                    {
                        $certPath = "Cert:\{0}\CA\{1}"
                        $certStoreName = 'Intermediate CA'
                        $boolCertResource = $true
                    }
                    'RootCATrustedCertificates\/TrustedPublisher' 
                    {
                        $certPath = "Cert:\{0}\TrustedPublisher\{1}"
                        $certStoreName = 'Trusted Publisher'
                        $boolCertResource = $true
                    }
                }

                if($boolCertResource)
                {
                    # Determine the certificate store type based on the resource path
                    switch -Regex ($resource) 
                    {
                        '^\.\/device\/' { $tmpPathType = 'LocalMachine'; break }
                        '^\.\/user\/'   { $tmpPathType = 'CurrentUser'; break }
                        default         { $tmpPathType = 'LocalMachine' }
                    }
                
                    # Lets get the certificate details by thumbprint
                    $tmpThumbprint = $resource | Split-Path -Leaf -ErrorAction SilentlyContinue
                    # Addind the middle part to the path string at the thumbprint at the end
                    $certPath = $certPath -f $tmpPathType, $tmpThumbprint

                    if (Test-Path $certPath) 
                    {
                        # Looking for a cert locally
                        [array]$cert = Get-Item -Path "$certPath" -ErrorAction SilentlyContinue
                    }
                    if ($cert) 
                    {
                        $resource = '{0} ➡️ {1}' -f $resource,  ($cert.Subject -replace '^.*CN=([^,]+),.*$', '$1' -replace '^CN=')
                        $tmpCertObj.CertStore = $certStoreName
                        $tmpCertObj.IssuedTo = ($cert.Subject -replace '^.*CN=([^,]+),.*$', '$1' -replace '^CN=')
                        $tmpCertObj.Issuer = $cert.Issuer -replace '^CN='
                        $tmpCertObj.Thumbprint = $tmpThumbprint
                        $tmpCertObj.ValidFrom = $cert.NotBefore.ToString("yyyy-MM-dd HH:mm:ss")
                        $tmpCertObj.ValidTo = $cert.NotAfter.ToString("yyyy-MM-dd HH:mm:ss")
                        $tmpCertObj.ExpireDays = try{[math]::Round(($cert.NotAfter - (Get-Date)).TotalDays, 2)} catch { 'N/A' }
                    }
                    else 
                    {
                        $resource = '{0} ➡️ {1}' -f $resource,  ($cert.Subject -replace '^.*CN=([^,]+),.*$', '$1' -replace '^CN=')
                        $tmpCertObj.CertStore = $certStoreName
                        $tmpCertObj.IssuedTo = $null
                        $tmpCertObj.Issuer = $null
                        $tmpCertObj.Thumbprint = $tmpThumbprint
                        $tmpCertObj.ValidFrom = $null
                        $tmpCertObj.ValidTo = $null
                        $tmpCertObj.ExpireDays = $null                  
                    }
                }
                
                # Putting it all together
                $outObj = [pscustomobject]@{
                    PolicyScope = 'Resource'
                    EnrollmentId = $enrollmentID
                    ProviderID = $script:enrollmentProviderIDs[$enrollmentID]
                    ResourceTarget = $resourceTarget
                    ResourceName = $resource
                    ResourceType = $tmpResourceType    
                    ResourceData = if($boolCertResource){$tmpCertObj}else{$null}
                }
                $outList.Add($outObj)
            }
            
        }
    }
    return $outList
}
#endregion


#region Convert-FileTimeToDateTime 
function Convert-FileTimeToDateTime 
{
    param 
    (
        [Parameter(Mandatory = $true)]
        [UInt64]$FileTime
    )

    $seconds = $FileTime / 10000000

    # FILETIME epoch starts at January 1, 1601 (UTC)
    # PowerShell 5.1 doesn't support -AsUTC, so use DateTime with Kind set to UTC
    $epoch = [DateTime]::SpecifyKind([DateTime]::Parse("1601-01-01T00:00:00"), [DateTimeKind]::Utc)

    # Add the seconds to the epoch
    $datetime = $epoch.AddSeconds($seconds)

    # Format the output
    return $datetime.ToString("yyyy-MM-dd HH:mm:ss")
}
#endregion


#region Get-IntuneMSIPolicies
Function Get-IntuneMSIPolicies
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        $MDMData
    )


    $StatusCodes = @{
        10 = "⚙️ Initialized"
        20 = "⬇️ Download In Progress"
        25 = "🔁 Pending Download Retry"
        30 = "❌ Download Failed"
        40 = "✅ Download Completed"
        48 = "🧑‍💻 Pending User Session"
        50 = "⚙️ Enforcement In Progress"
        55 = "🔁 Pending Enforcement Retry"
        60 = "🚫 Enforcement Failed"
        70 = "✅ Enforcement Completed"
    }

    $outList = [System.Collections.Generic.List[pscustomobject]]::new()
    Foreach ($user in $MDMData.MDMEnterpriseDiagnosticsReport.EnterpriseDesktopAppManagementinfo.MsiInstallations.TargetedUser)
    {
        $assignmentIdentity = if($user.UserSID -eq 'S-0-0-00-0000000000-0000000000-000000000-000'){'Device'}else{$user.UserSID}
        
        foreach ($package in $user.Package)
        {
            foreach ($packageDetail in $package.Details)
            {  

                if ([string]::IsNullOrEmpty($packageDetail.CurrentDownloadUrl))
                {
                    $possibleAppName = 'Unknown'    
                }
                else 
                {
                    $possibleAppName = ($packageDetail.CurrentDownloadUrl | Split-Path -Leaf -ErrorAction SilentlyContinue)
                }

                # A specifc order helps to keep the output consistent and easier to find information
                $outObj = [PSCustomObject][ordered]@{
                    PossibleAppName = $possibleAppName
                    AssignmentIdentity = $assignmentIdentity
                    Status = $packageDetail.Status
                    LastError = $packageDetail.LastError
                    ProductVersion = $packageDetail.ProductVersion
                    ProductCode = $packageDetail.ProductCode
                    CreationTime = $packageDetail.CreationTime
                    EnforcementStartTime = $packageDetail.EnforcementStartTime
                    CurrentDownloadUrl = $packageDetail.CurrentDownloadUrl
                    CommandLine = $packageDetail.CommandLine
                    DownloadLocation = $packageDetail.DownloadLocation
                    DownloadInstall = $packageDetail.DownloadInstall
                    EnforcementRetryCount = $packageDetail.EnforcementRetryCount
                    EnforcementRetryIndex = $packageDetail.EnforcementRetryIndex
                    EnforcementRetryInterval = $packageDetail.EnforcementRetryInterval
                    EnforcementTimeout = $packageDetail.EnforcementTimeout
                    FileHash = $packageDetail.FileHash
                    LocURI = $packageDetail.LocURI
                    ActionType = $packageDetail.ActionType
                    AssignmentType = $packageDetail.AssignmentType
                    BITSJobId = $packageDetail.BITSJobId
                    JobStatusReport = $packageDetail.JobStatusReport
                    ServerAccountID = $packageDetail.ServerAccountID
                    PackageId = $packageDetail.PackageId
                    PackageType = 'MSI'
                    PolicyScope = 'EnterpriseDesktopAppManagement'                    
                }

                try 
                {
                    $tmpCreationTime = Convert-FileTimeToDateTime -FileTime $outObj.CreationTime   
                    $outObj.CreationTime = $tmpCreationTime
                }
                catch {
                    Write-Host "Failed to convert CreationTime for package: $($outObj.PackageId). Error: $_"
                }

                try 
                {
                    $tmpEnforcementStartTime = Convert-FileTimeToDateTime -FileTime $outObj.EnforcementStartTime   
                    $outObj.EnforcementStartTime = $tmpEnforcementStartTime
                }
                catch {
                    Write-Host "Failed to convert EnforcementStartTime for package: $($outObj.PackageId). Error: $_"
                }
                # Convert the status code to a human-readable string
                try
                {
                    $tmpStatus = $StatusCodes[[int]($outObj.Status)]
                    $outObj.Status = $tmpStatus
                }catch{}
                 

                $outList.Add($outObj)
            }
        }      
    }

    $outListSorted = $outList | Sort-Object -Property PossibleAppName, CreationTime -Descending

    return $outListSorted
}
#endregion


#region Get-IntunePolicyCurrentData
Function Get-IntunePolicyCurrentData
{
    param 
    (
        [Parameter(Mandatory = $true)]
        [string]$PolicyScope,
        [Parameter(Mandatory = $true)]
        [string]$PolicyAreaName,
        [Parameter(Mandatory = $true)]
        [string]$PolicyName,
        [Parameter(Mandatory = $true)]
        $MDMData
    )
    
    # Define the policy scope to filter by
    [array]$PolicyScopeData = $MDMData.MDMEnterpriseDiagnosticsReport.PolicyManager.currentPolicies | Where-Object { $_.PolicyScope -eq $PolicyScope }

    # Search for the specific policy area and policy name
    $PolicyObj = $PolicyScopeData.CurrentPolicyValues | Where-Object { $_.PolicyAreaName -eq $PolicyAreaName} 

    # Looking for the specific policy name
    $resultObj = $PolicyObj | select-object -Property "$($PolicyName)_ProviderSet", "$($PolicyName)_WinningProvider"

    return $resultObj
}
#endregion


#region Get-IntunePolicyMetadata
function Get-IntunePolicyMetadata
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        [string]$PolicyAreaName,
        [Parameter(Mandatory = $true)]
        [string]$PolicyName,
        [Parameter(Mandatory = $true)]
        $MDMData
    )

    $outObj = [pscustomobject]@{
        RedirectionPath = "Redirection path not set"
        DefaultValue = "No default value set"
    }

    # PolicymetaData is a collection of metadata for each policy 
    # We are interested in the regpah or translationDllPath for the specific policy
    $policyMetaData = $MDMData.MDMEnterpriseDiagnosticsReport.PolicyManagerMeta.AreaMetadata | Where-Object { $_.PolicyAreaName -eq $PolicyAreaName }
    if (-not $policyMetaData) 
    {
        return $outObj
    }
    else 
    {
        $policy = $policyMetaData.PolicyMetadata | Where-Object { $_.PolicyName -eq $PolicyName } 
        if (-not $policy) 
        {
            return $outObj
        }
        else 
        {
            if (-NOT ([string]::IsNullOrEmpty($policy.value))) 
            {
                # If the policy has a value, return it as the default value
                $outObj.DefaultValue = $policy.value
            }

            # If the policy has a RegKeyPathRedirect, return it
            if (-NOT ([string]::IsNullOrEmpty($policy.RegKeyPathRedirect))) 
            {
                $outObj.RedirectionPath = 'RegKeyPathRedirect: {0}' -f $policy.RegKeyPathRedirect
            }

            # If the policy has a translationDllPath, return it
            if(-not ([string]::IsNullOrEmpty($policy.translationDllPath)))
            {
                $outObj.RedirectionPath = 'TranslationDllPath: {0}' -f $policy.translationDllPath
            }

            # If the policy has a grouppolicyPath, return it
            if(-not ([string]::IsNullOrEmpty($policy.grouppolicyPath)))
            {
                $outObj.RedirectionPath = 'GroupPolicyPath: {0}' -f $policy.grouppolicyPath
            }   

            # precheckDllPath
            if(-not ([string]::IsNullOrEmpty($policy.precheckDllPath)))
            {
                $outObj.RedirectionPath = 'PrecheckDllPath: {0}' -f $policy.precheckDllPath
            }

            # GPBlockingRegKeyPath
            if(-not ([string]::IsNullOrEmpty($policy.GPBlockingRegKeyPath)))
            {
                $outObj.RedirectionPath = 'GPBlockingRegKeyPath: {0}' -f $policy.GPBlockingRegKeyPath
            }
        }
    }
    return $outObj
}
#endregion


#region Get-EnrollmentIDData
function Get-EnrollmentIDData
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        [string]$EnrollmentId,
        [Parameter(Mandatory = $true)]
        $MDMData
    )

    $enrollmentObj = $MDMData.MDMEnterpriseDiagnosticsReport.Enrollments.Enrollment | Where-Object {$_.EnrollmentId -eq $EnrollmentId} 
    # If no enrollment object is found, return null
    if (-not $enrollmentObj) 
    {
        #Write-Error "Enrollment ID '$EnrollmentId' not found."
        return $null
    }
    else
    {
        return [pscustomobject][ordered]@{
            EnrollmentId = $enrollmentObj.EnrollmentId
            EnrollmentState = $enrollmentObj.EnrollmentState
            EnrollmentType = $enrollmentObj.EnrollmentType
            CurCryptoProvider = $enrollmentObj.CurCryptoProvider
            DiscoveryServiceFullURL = $enrollmentObj.DiscoveryServiceFullURL
            DMServerCertificateThumbprint = $enrollmentObj.DMServerCertificateThumbprint
            IsFederated = $enrollmentObj.IsFederated
            ProviderID = if ($null -eq $enrollmentObj.ProviderID) 
            {
                'Local'
            }
            elseif ($enrollmentObj.ProviderID -eq 'MS DM Server') 
            {
                'Intune'
            }
            else
            {
                $enrollmentObj.ProviderID
            }

            RenewalPeriod = $enrollmentObj.RenewalPeriod
            RenewalErrorCode = $enrollmentObj.RenewalErrorCode
            RenewalROBOSupport = $enrollmentObj.RenewalROBOSupport
            RenewalStatus = $enrollmentObj.RenewalStatus
            RetryInterval = $enrollmentObj.RetryInterval
            RootCertificateThumbPrint = $enrollmentObj.RootCertificateThumbPrint
            IsRecoveryAllowed = $enrollmentObj.IsRecoveryAllowed
            DMClient = $enrollmentObj.DMClient
            Poll = $enrollmentObj.Poll
            FirstSync = $enrollmentObj.FirstSync
            UserFirstSync = $enrollmentObj.UserFirstSync
            Push = $enrollmentObj.Push
        }
    }
}
#endregion


#region Get-EnrollmentProviderIDs
function Get-EnrollmentProviderIDs
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        $MDMData
    )
    
    $enrollmentHashTable = @{}
    foreach($enrollment in $MDMData.MDMEnterpriseDiagnosticsReport.Enrollments.Enrollment)
    {
        $providerID = $enrollment.ProviderID
        if ($enrollment.EnrollmentId -match '[a-fA-F0-9\-]{36}')
        {
            If([string]::IsNullOrEmpty($enrollment.ProviderID))
            {
                # Logic to get a ppkg file name from the MDMEnterpriseDiagnosticsReport
                $providerPackage = $MDMData.MDMEnterpriseDiagnosticsReport.ProvisioningResults.Result | Where-Object -Property PackageID -eq "{$($enrollment.EnrollmentId)}"
                if ($providerPackage)
                {
                    $providerID = $providerPackage.PackageFileName
                }
                else 
                {                    
                    $providerID = 'Local'
                    try 
                    {
                        # try to extract the enrollment name from a string like this:
                        # '<td valign="top" class="ColumnHeader">EnrollmentEnrollTypeUpdatePolicy</td><td valign="top">B04F44A4-B696-4B56-934A-C11667E944E4</td>'
                        $content = Get-Content -Path $script:MDMDiagHTMLReportPathVariable -Raw
                        $pattern = '<td[^>]*>(?<EnrollmentName>[^<]+)</td>\s*<td[^>]*>' + [regex]::Escape($enrollment.EnrollmentId) + '</td>'
                        $regexResult = $null
                        $regexResult = [regex]::Match($content, $pattern, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
                        $providerID = $result.Groups['EnrollmentName'].Value
                    }
                    catch{}
                }
            }
            elseif ($enrollment.ProviderID -eq 'MS DM Server')
            {
                $providerID = 'Intune'
            }

            # Add the EnrollmentId and ProviderID to the hash table
            $enrollmentHashTable[$enrollment.EnrollmentId] = $providerID
        }
        else 
        {
            # If the EnrollmentId is not in the expected format, skip it
            continue
        }
    }

    return $enrollmentHashTable
}
#endregion


#region Invoke-EscapeHtmlText
function Invoke-EscapeHtmlText 
{
    param 
    (
        [string]$Text
    )

    try 
    {
        return [System.Web.HttpUtility]::HtmlEncode($Text)  
    }
    catch 
    {
        return $Text -replace '&', '&amp;' `
                    -replace '<', '&lt;' `
                    -replace '>', '&gt;' `
                    -replace '"', '&quot;' `
                    -replace "'", '&#39;'
    }
}
#endregion


#region Get-DeviceAndUserHTMLTables
Function Get-DeviceAndUserHTMLTables
{
    param
    (
        [Parameter(Mandatory = $true)]
        [array]$GroupedPolicies
    )

    $htmlBody = ""
    $selection = $GroupedPolicies.Where({($_.Name -eq 'Device') -or ($_.Name -match 'S-\d+(-\d+)+')})
    $deviceSelection = $GroupedPolicies.Where({ $_.Name -eq 'Device' })
    #$userSelection = $GroupedPolicies.Where({ $_.Name -match 'S-\d+(-\d+)+' })
    foreach ($group in $selection) 
    {
        if ($group.Name -eq 'Device') 
        { 
            $statString = "TotalPolicyAreas: {0}<br>TotalSettings: {1}" -f $deviceSelection.group.count, $deviceSelection.group.Settings.count
            $areaTitleString = '💻 Device'
        } 
        else 
        { 
            # We need to get the right numbers per user, not for all users together
            [array]$tmpUserStatsSelection = $GroupedPolicies.Where({ $_.Name -eq $group.Name})
            $tmpTotalAreas = 0
            $tmpTotalAreas = try{($tmpUserStatsSelection | Select-Object -Property Count).Count}catch{}
            $tmpTotalSettings = 0
            $tmpTotalSettings = $tmpUserStatsSelection.group.Settings.count

            $statString = "TotalPolicyAreas: {0}<br>TotalSettings: {1}" -f $tmpTotalAreas, $tmpTotalSettings

            if ([string]::IsNullOrEmpty($group.group[0].PolicyScopeDisplay)) 
            {
                $areaTitleString = '👤 {0}: Unknown'
            }
            else 
            {
                $areaTitleString = '👤 {0}: {1}' -f $group.Name, $group.group[0].PolicyScopeDisplay
            }
        }
        
        $htmlBody += "<div class='group-container'>"
        $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
        $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
        $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
        $htmlBody += "</div>"
        $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
        $htmlBody += "<div class='collapsible-content'>"
        
        $i = 0
        foreach ($policy in ($group.Group | Sort-Object -Property PolicyAreaName)) 
        {
            if ($i -gt 0) 
            {
                $htmlBody += "<br><br>"
            }

            $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>" 
            $htmlBody += "<button class='toggle-button-inner' onclick='toggleContent(this)'>Hide</button>" 
            $htmlBody += "<h2 class='policy-area-title'>PolicyArea: $($policy.PolicyAreaName)</h2>"
            $htmlBody += "</div>" 
            $htmlBody += "<div class='collapsible-content'>" 
            $htmlBody += "<table class='main-table'>"
            $htmlBody += "<tr><td style='font-weight: bold; width: 400px;'>EnrollmentId</td><td>$($policy.EnrollmentId) ➡️ $($policy.EnrollmentProvider)</td><td style='width: 150px;'></td><td style='width: 200px;'></td></tr>"
            $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold; width: 400px;'>Setting ⚙️</th><th>Value</th><th style='width: 150px;'>DefaultValue</th><th style='width: 200px;'>WinningProvider</th></tr>"

            foreach ($settings in $policy.Settings) 
            {
                $settingspath = 'Path or DLL of the setting: "{0}"' -f $settings.Metadata.RedirectionPath

                if ($settings.WinningProvider -eq 'Not set' -or [string]::IsNullOrEmpty($settings.WinningProvider)) 
                {
                    $winningProviderString = $policy.EnrollmentProvider
                } 
                else 
                {
                    $tmpValue = $script:enrollmentProviderIDs[$settings.WinningProvider]
                    if ($tmpValue) 
                    {
                        $winningProviderString = $tmpValue
                    }
                    else 
                    {
                        $winningProviderString = $settings.WinningProvider
                    }
                }

                if ($winningProviderString.Trim() -ne $policy.EnrollmentProvider.Trim()) 
                {
                    $winningProviderString = "ℹ️ $winningProviderString"
                } 

                $value = Invoke-EscapeHtmlText -Text ($settings.Value -replace '&quot;', '"')
                $defaultValue = $settings.Metadata.DefaultValue
                $htmlBody += "<tr><td class='setting-col'>$($settings.Name)</td><td title='$($settingspath)'>$value</td><td style='width: 150px;'>$defaultValue</td><td style='width: 200px;'>$winningProviderString</td></tr>"
            }

            $htmlBody += "</table>"
            $htmlBody += "</div>"  # Close collapsible-content
            $i++
        }
        $htmlBody += "</div>"  # Close collapsible-content
        $htmlBody += "</div>"  # Close group-container
    }

    return $htmlBody
}
#endregion


#region Get-EnterpriseApplicationHTMLTables
function Get-EnterpriseApplicationHTMLTables 
{
    param
    (
        [Parameter(Mandatory = $true)]
        [array]$GroupedPolicies
    )

    $htmlBody = ""

    $enterpriseAppGroup = $GroupedPolicies.Where({ $_.Name -eq 'EnterpriseDesktopAppManagement' })

    $areaTitleString = '📦 EnterpriseDesktopAppManagement'
    $statString = "TotalAppPolicies: {0}" -f $enterpriseAppGroup.Group.Count

    $htmlBody = ""
    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
    $htmlBody += "<div class='collapsible-content'>"

    foreach ($app in $enterpriseAppGroup.Group)
    {

        $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>" 
        $htmlBody += "<button class='toggle-button-inner' onclick='toggleContent(this)'>Hide</button>" 
        $htmlBody += "<h2 class='policy-area-title'>App: $($app.possibleAppName)</h2>"
        $htmlBody += "</div>" 
        $htmlBody += "<div class='collapsible-content'>" 
        $htmlBody += "<table class='main-table'>"

        # Let's exclude some properties that are not relevant for the report
        $excludedProperties = @('PossibleAppName','ActionType', 'AssignmentType', 'BITSJobId', 'JobStatusReport', 'PolicyScope', 'ServerAccountID', 'PackageId', 'LocURI', 'PackageType')

        foreach ($property in ($app.PSObject.Properties))
        {
            if ($property.Name -in $excludedProperties) 
            {
                continue
            }

            $value = Invoke-EscapeHtmlText -Text ($property.Value)
            $htmlBody += "<tr><td style='font-weight: bold; width: 400px;'>$($property.Name)</td><td>$value</td></tr>"
        }
        
        $htmlBody += "</table>"
        $htmlBody += "</div>"  # Close collapsible-content
        $htmlBody += "<br>"
    }
    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody
}
#endregion


#region Get-ResourceHTMLTables
Function Get-ResourceHTMLTables
{
    param
    (
        [Parameter(Mandatory = $true)]
        [array]$GroupedPolicies
    )

    # Does not make sense when we use XML data from a different system. 
    # But does also not harm, because the report will simply not be able to match a SID to a username.
    $userInfoHash = Get-LocalUserInfo

    $resourcePolicies = $GroupedPolicies.Where({ $_.Name -eq 'Resource' }) 
    $groupedResources = $resourcePolicies.group | Group-Object -Property ResourceType, EnrollmentId 
    
    $areaTitleString = '🌐 Resources'
    $statString = "TotalResources: {0}" -f $groupedResources.Group.Count

    $htmlBody = ""
    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
    $htmlBody += "<div class='collapsible-content'>"

    foreach ($resourceEntry in ($groupedResources | Sort-Object -Property Name -Descending)) 
    {
        # Split the ResourceType, EnrollmentId from a single string
        # The format is "EResourceType, EnrollmentId"
        $tmpSplitVar = $resourceEntry.Name -split ',' # 0 = ResourceType, 1 = EnrollmentId

        $tmpResourceType = $tmpSplitVar[0].ToString().Trim()
        $tmpEnrollmentId = $tmpSplitVar[1].ToString().Trim()
        $enrollmentIdString = '{0} ➡️ {1}' -f $tmpEnrollmentId, ($resourceEntry.Group[0].ProviderID)

        $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>" 
        $htmlBody += "<button class='toggle-button-inner' onclick='toggleContent(this)'>Hide</button>" 
        $htmlBody += "<h2 class='policy-area-title'>ResourceType: $($tmpResourceType)</h2>"
        $htmlBody += "</div>" 
        $htmlBody += "<div class='collapsible-content'>" 
        $htmlBody += "<table class='main-table'>"
        #$htmlBody += "<tr><td style='font-weight: bold;'>EnrollmentId</td><td colspan='5'>$($enrollmentIdString)</td></tr>"

        if ($tmpResourceType -eq 'RootCATrustedCertificates')
        {
            $htmlBody += "<tr><td style='font-weight: bold;'>EnrollmentId</td><td colspan='5'>$($enrollmentIdString)</td></tr>"
            $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold;'>ResourceTarget ⚙️</th><th>CertStore</th><th>Thumbprint</th><th>IssuedTo</th><th>Issuer</th><th>ExpiresIn</th></tr>"
        }
        elseif ($tmpResourceType -eq 'Firewall') 
        {
            $htmlBody += "<tr><td style='font-weight: bold;'>EnrollmentId</td><td colspan='3'>$($enrollmentIdString)</td></tr>"
            $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold;'>ResourceTarget ⚙️</th><th>Resource</th><th>Name</th><th>Value</th></tr>"
        }
        else 
        {
            $htmlBody += "<tr><td style='font-weight: bold; width: 500px;'>EnrollmentId</td><td>$($enrollmentIdString)</td></tr>"
            $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold; width: 500px;'>ResourceTarget ⚙️</th><th>Resource</th></tr>"
        }

        foreach ($resource in $resourceEntry.Group) 
        {
            
            if ($resource.ResourceTarget -eq 'Device') 
            {
                $resourceTargetString = '💻 Device'
            } 
            else 
            {
                $userName = $userInfoHash[$resource.ResourceTarget]
                if ([string]::IsNullOrEmpty($userName))
                {
                    $resourceTargetString = '👤 {0} - Unknown' -f ($resource.ResourceTarget)
                }
                else
                {
                    $resourceTargetString = '👤 {0} - {1}' -f ($resource.ResourceTarget), $userName
                }
            }

            # If the resource is a certificate, we need to display the certificate details
            if ($tmpResourceType -eq 'RootCATrustedCertificates')
            {
                # If the resource is a certificate, we can display the certificate details
                $tmpExpireDays = $resource.ResourceData.ExpireDays
                try 
                {
                    if (([int]$resource.ResourceData.ExpireDays -le 0) -and -not ([string]::IsNullOrEmpty($resource.ResourceData.ExpireDays)))
                    {
                        $tmpExpireDays = '⚠️ {0}' -f $resource.ResourceData.ExpireDays   
                    }
                }
                catch {}

                $htmlBody += "<tr><td class='setting-col'>$($resourceTargetString)</td>"
                $htmlBody += "<td>$($resource.ResourceData.CertStore)</td>"
                $htmlBody += "<td>$($resource.ResourceData.Thumbprint)</td>"
                $htmlBody += "<td>$($resource.ResourceData.IssuedTo)</td>"
                $htmlBody += "<td>$($resource.ResourceData.Issuer)</td>"
                $htmlBody += "<td>$($tmpExpireDays)</td>"
                $htmlBody += "</tr>"

            }
            elseif ($tmpResourceType -eq 'Firewall') 
            {
                # If the resource is a firewall setting, we can try to display the firewall setting details
                $tmpName = ''
                $tmpFirewallSetting = ''

                $tmpSplit = $resource.ResourceName -split '\/'
                try 
                {
                    $tmpFirewallSetting = Get-MDMFirewallSetting -Topic ($tmpSplit[-2]) -SettingName ($tmpSplit[-1])
                }
                catch 
                {
                    $tmpFirewallSetting = $resource.ResourceName
                }
                 
                if ($resource.ResourceName -match 'FirewallRules')
                {
                    $tmpName = $tmpFirewallSetting -replace '.*\|Name=([^|]+)\|.*', '$1'
                }
                else 
                {
                    $tmpName = ($tmpSplit[-1])
                }

                $tmpResourceName = '{0}\{1}' -f ($tmpSplit[-2]), ($tmpSplit[-1])

                $htmlBody += "<tr><td class='setting-col'>$($resourceTargetString)</td>"
                $htmlBody += "<td>$($tmpResourceName)</td>"
                $htmlBody += "<td>$($tmpName)</td>"
                $htmlBody += "<td>$($tmpFirewallSetting)</td>"
                $htmlBody += "</tr>"
            }
            else 
            {
                # If the is an Office installation, we can get the install parameters from registry to display them in the report
                $tmpResourceName = $resource.ResourceName
                
                if ($tmpResourceName -match 'MSFT/Office/Installation')
                {
                    $officeResult = try{Get-IntuneOfficeInstallParams -ID ($tmpResourceName | Split-Path -Leaf)}catch{}
                    if ($officeResult)
                    {
                        # Escape the resource name to prevent the resource name from breaking our HTML
                        $officeResultEscaped = Invoke-EscapeHtmlText -Text ($officeResult)   
                        # We want to display the resource name and the office result in a single cell
                        $resourceName = '{0}<br><br>{1}' -f $tmpResourceName, $officeResultEscaped
                    }
                    else 
                    {
                        # Escape the resource name to prevent the resource name from breaking our HTML
                        $resourceName = Invoke-EscapeHtmlText -Text ($tmpResourceName)
                    }
                }
                else
                {
                    # Escape the resource name to prevent the resource name from breaking our HTML
                    $resourceName = Invoke-EscapeHtmlText -Text ($tmpResourceName)
                }

                $htmlBody += "<tr><td class='setting-col'>$($resourceTargetString)</td><td>$resourceName</td></tr>"
            }
        }
        
        $htmlBody += "</table>"
        $htmlBody += "</div>"
        $htmlBody += "<br>"

    }
    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody
}
#endregion


#region Get-IntuneWin32AppTables
Function Get-IntuneWin32AppTables
{
    $win32Apps = Get-IntuneWin32AppPolicies -LogPath $script:MDMDiagReportPathVariable

    $htmlBody = ""

    $areaTitleString = '🪟 Win32Apps'
    $statString = "TotalWin32AppPolicies: {0}" -f $win32Apps.Count

    $htmlBody = ""
    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
    $htmlBody += "<div class='collapsible-content'>"

    $excludedProperties = @('PolicyScope', 'ServerAccountID', 'PackageId')

    foreach ($app in $win32Apps) 
    {
        $htmlBody += "<div class='app-container'>"
        $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>" 
        $htmlBody += "<button class='toggle-button-inner' onclick='toggleContent(this)'>Hide</button>" 
        $htmlBody += "<h2 class='policy-area-title'>Win32App: $($app.Name)</h2>"
        $htmlBody += "</div>" 
        $htmlBody += "<div class='collapsible-content'>" 
        $htmlBody += "<table class='main-table'>"
        foreach ($property in ($app.PSObject.Properties | Sort-Object -Property Name | Where-Object { $_.Name -notin $excludedProperties })) 
        {
            # Lets format the AppState property to be a list in html
            $propertyValue = ''

            # Properties we will use some special formatting for to make the easier to read.
            switch ($property.Name) 
            {
                'AppState' 
                {  
                    if ([string]::IsNullOrEmpty($property.Value))
                    {
                        $propertyValue = "No app state found"
                    }
                    else 
                    {
                        $propertyValue = ConvertTo-HTMLTableFromArray -InputList ($property.Value) -ErrorAction SilentlyContinue
                        if ([string]::IsNullOrEmpty($propertyValue)) 
                        {
                            # Fallback to the original value if the conversion fails or is empty
                            $propertyValue = $property.Value
                        }
                    }                   
                }

                'DetectionRule'
                {
                    try 
                    {
                        [array]$tmpJsonString = $property.Value | ConvertFrom-Json -ErrorAction Stop
                        Foreach($item in $tmpJsonString)
                        {
                            $item.DetectionText = $item.DetectionText | ConvertFrom-Json # could be done with -depth parameter, but not in posh 5.1 
                            $propertyValue = Get-HTMLTableFromData -InputData $item.DetectionText -TableType 'ScriptBody'
                        }
                    }
                    catch 
                    {
                        # In case of an error we will just use the original string
                        $propertyValue = $property.Value
                    }                    
                }

                'RequirementRules'
                {
                    try 
                    {
                        [array]$tmpJsonString = $property.Value | ConvertFrom-Json -ErrorAction Stop
                        Foreach($item in $tmpJsonString)
                        {
                            $propertyValue += ConvertTo-HTMLTableFromArray -InputList $item
                        }
                    }
                    catch 
                    {
                        # In case of an error we will just use the original string
                        $propertyValue = $property.Value
                    }                   
                }

                'ExtendedRequirementRules'
                {
                    try 
                    {
                        [array]$tmpJsonString = $property.Value | ConvertFrom-Json -ErrorAction Stop
                        Foreach($item in $tmpJsonString)
                        {
                            $item.RequirementText = $item.RequirementText | ConvertFrom-Json # could be done with -depth parameter, but not in posh 5.1 
                            $propertyValue += Get-HTMLTableFromData -InputData $item.RequirementText -TableType 'ScriptBody'
                        }
                    }
                    catch 
                    {
                        # In case of an error we will just use the original string
                        $propertyValue = $property.Value
                    }                   
                }

                # script block detection to account for multiple properties
                { $_ -in @('InstallEx','ReturnCodes','InstallerData','RebootEx','StartDeadlineEx')}
                {     
                    $propertyValue = Get-HTMLTableFromData -InputData $property.Value 
                }

                Default 
                {
                    $propertyValue = $property.Value               
                }
                    
            }
            
            $htmlBody += "<tr><td style='font-weight: bold; width: 300px;'>$($property.Name)</td><td>$($propertyValue)</td></tr>"
        }
        $htmlBody += "</table>"
        $htmlBody += "</div>"  # Close collapsible-content
        $htmlBody += "<br>"
        $htmlBody += "</div>"  # Close collapsible-content
    }
    
    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody
}
#endregion


#region Get-DeviceInfoHTMLTables
Function Get-DeviceInfoHTMLTables
{
    param
    (
        [Parameter(Mandatory = $true)]
        [array]$GroupedPolicies
    )

    $htmlBody = ""

    $deviceInfoData = $GroupedPolicies.Where({ $_.Name -eq 'DeviceInfo' }) 

    # Set the area title string based on the DeviceName
    # If the DeviceName is empty or null, set it to 'Unknown'
    if ([string]::IsNullOrEmpty($deviceInfoData.group[0].DeviceName)) 
    {
        $areaTitleString = '💻 Unknown'
    }
    else 
    {
        $areaTitleString = "💻 $($deviceInfoData.group[0].DeviceName)"
    }

    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>DeviceInfo: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<div class='collapsible-content'>"

    foreach ($device in $deviceInfoData.group) 
    {
        $htmlBody += "<table class='main-table'>"
        $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold; width: 300px;'>Property ⚙️</th><th>Value</th></tr>"

        foreach ($property in ($device.PSObject.Properties)) 
        {
            #skip properties that are not relevant for the report
            if ($property.Name -in @('PolicyScope', 'DeviceName')) 
            {
                continue
            }
            $htmlBody += "<tr><td style='font-weight: bold; width: 300px;'>$($property.Name)</td><td>$($property.Value)</td></tr>"
        }
        $htmlBody += "</table>"
        $htmlBody += "<br>"
    }

    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody
}
#endregion


#region Get-DeviceInfoHTMLTables
Function Get-LAPSHTMLTables
{
    param
    (
        [Parameter(Mandatory = $true)]
        [array]$GroupedPolicies
    )

    $infoData = $GroupedPolicies.Where({ $_.Name -eq 'LAPS' }) 

    $areaTitleString = "🔑 Local Admin Password Solution (LAPS)"

    if ($infoData) 
    {
        $statString = "LAPS policy: 1"
    }
    else 
    {
        $statString = "LAPS policy: 0"
    }
    
    $htmlBody = "" 
    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
    $htmlBody += "<div class='collapsible-content'>"
    

    foreach ($item in $infoData.group) 
    {
        $htmlBody += "<table class='main-table'>"
        $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold; width: 300px;'>Setting ⚙️</th><th>Value</th></tr>"
        foreach ($property in ($item.PSObject.Properties)) 
        {
            #skip properties that are not relevant for the report
            if ($property.Name -in @('PolicyScope')) 
            {
                continue
            }
            $htmlBody += "<tr><td style='font-weight: bold; width: 300px;'>$($property.Name)</td><td>$($property.Value)</td></tr>"
        }
        $htmlBody += "</table>"
        $htmlBody += "<br>"
    }

    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody
}
#endregion

#region Get-IntuneScriptPolicyTables
Function Get-IntuneScriptPolicyTables
{
    [array]$scriptPolicies = Get-IntuneScriptPolicies -LogPath $script:MDMDiagReportPathVariable

    $htmlBody = ""

    $areaTitleString = '📜 Intune Scripts'
    $statString = "TotalIntuneScriptPolicies: {0}" -f $scriptPolicies.Count

    $htmlBody = ""
    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
    $htmlBody += "<div class='collapsible-content'>"

    foreach ($script in ($scriptPolicies | Sort-Object -Property PolicyID)) 
    {
        $htmlBody += "<div class='app-container'>"
        $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>" 
        $htmlBody += "<button class='toggle-button-inner' onclick='toggleContent(this)'>Hide</button>" 
        $htmlBody += "<h2 class='policy-area-title'>ScriptID: $($script.PolicyID)</h2>"
        $htmlBody += "</div>" 
        $htmlBody += "<div class='collapsible-content'>" 
        $htmlBody += "<table class='main-table'>"
        foreach ($property in $script.PSObject.Properties) 
        {
            $propertyName = $property.Name
            Switch ($property.Name)
            {
                'UserId'
                {
                    if ($property.Value -eq '00000000-0000-0000-0000-000000000000') 
                    {
                        # this is a device script, so we can set the value to "Device" with icon
                        $property.Value = "💻 Device"
                    } 
                    else 
                    {
                        $property.Value = "👤 {0}" -f $property.Value
                    }
                }
            
                'PreRemediationDetectScriptOutput'
                {
                    $propertyName = 'PreRemediationDetectScriptOutput 🔍'
                }

                'PostRemediationDetectScriptOutput'
                {
                    $propertyName = 'PostRemediationDetectScriptOutput 🛠️'
                }


                { $_ -in @('ResultDetails','Info','Schedule')}
                {
                    $property.Value = Get-HTMLTableFromData -InputData $property.Value
                }

                'ErrorCode'
                {
                    if ($property.Value -ne 0)
                    {
                        $property.Value = '⚠️ {0}' -f $property.Value
                    }    
                }
            }

            $htmlBody += "<tr><td style='font-weight: bold; width: 300px;'>$($propertyName)</td><td>$($property.Value)</td></tr>"
        }

        $htmlBody += "</table>"
        $htmlBody += "</div>"  # Close collapsible-content
        $htmlBody += "<br>"
    }

    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody

}

#region Convert-IntunePoliciesToHtml
function Convert-IntunePoliciesToHtml 
{
    param 
    (
        [Parameter(Mandatory=$false)]
        [string]$OutputPath,

        [Parameter(Mandatory=$false)]
        [array]$Policies,

        [Parameter(Mandatory=$false)]
        [string]$Title = "Policy Report"
    )

    if ([string]::IsNullOrEmpty($script:MDMDiagReportPathVariable)) 
    {
        $headerSubText = "Generated locally running on $($env:COMPUTERNAME) on: 📅 $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    }
    else 
    {
        $headerSubText = "Generated from captured MDM Diagnostics Report on: 📅 $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    }

$htmlHeader = @"
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>$Title</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 14px; }
        h1 { font-size: 24px; color: #2E6DA4; }
        h2 { font-size: 18px; color: #444; margin-top: 10px; }

        .toggle-button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 5px 10px;
            margin-bottom: 10px;
            cursor: pointer;
            border-radius: 4px;
            width: 90px;           /* Fixed width for consistent size */
            text-align: center;     /* Center the text */
            box-sizing: border-box; /* Ensure padding is included in width */
        }

        .toggle-button-inner {
            background-color: #a5a5a5ff;
            color: white;
            border: none;
            padding: 5px 10px;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 11px;    /* Smaller font size for inner buttons */
            width: 70px;           /* Fixed width for consistent size */
            text-align: center;     /* Center the text */
            box-sizing: border-box; /* Ensure padding is included in width */
        }

        .toggle-button-inner-script {
            background-color: #ffffffff;
            color: #333333;              /* Darker text color for visibility */
            border: 2px solid #ccc;
            padding: 3px 6px;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;             /* Increased font size for visibility */
            /* font-weight: bold;           Make the symbol stand out */
            /* font-family: Arial, sans-serif;  Clean, readable font */
            width: 50px;           /* Fixed width for consistent size */
            height: 30px;           /* Fixed hight for consistent size */   
            text-align: center;     /* Center the text */
            box-sizing: border-box;  /* Ensure padding is included in width */
        }

        .collapsible-content {
            display: block;
            margin-top: 10px;
        }

        .group-container {
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            padding: 15px;
            margin-bottom: 30px;
            border-radius: 6px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.05);
        }

        .script-container {
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            padding: 5px;
            margin-bottom: 5px;
            border-radius: 6px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.05);
        }

        .policy-area-title {
            color: #2E6DA4;
        }
        

        /* === MAIN TABLE STYLING === */
        .main-table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 20px;
            table-layout: fixed;
            border: 3px solid #ddd;
            font-size: 13px;
        }

        .main-table th,
        .main-table td {
            border: 1px solid #ddd;
            padding: 8px;
            word-wrap: break-word;
            text-align: left;
            vertical-align: top;
            font-size: 13px;
        }

        .main-table th {
            background-color: #f2f2f2;
        }

        .main-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .main-table th.resource-col,
        .main-table td.resource-col {
            width: 100px;
        }

        /* === NESTED TABLE STYLING === */
        .nested-table {
            border: none !important;
            outline: none !important;
            background-color: transparent !important;
            border-collapse: collapse;
            width: 100%;
            table-layout: fixed;
            font-size: 13px;
        }

        .nested-table th,
        .nested-table td {
            background-color: transparent !important;
            outline: none !important;
            border: none !important;
            padding: 8px;
            word-wrap: break-word;
            text-align: left;
            vertical-align: top;
        }

        .nested-table td:first-child {
            width: 200px;
        }

    

    </style>
    <script>
       
        function toggleContent(button) {
            // Find the main content section to toggle
            let content = button.parentElement.nextElementSibling;

            if (!content || !content.classList.contains('collapsible-content')) {
                const groupContainer = button.closest('.group-container');
                content = groupContainer ? groupContainer.querySelector('.collapsible-content') : null;
            }

            if (!content) return;

            const isVisible = window.getComputedStyle(content).display !== "none";
            const newDisplay = isVisible ? "none" : "block";
            const newLabel = isVisible ? "Show" : "Hide";

            // Toggle the main content
            content.style.display = newDisplay;
            button.textContent = newLabel;

            // Also toggle all nested collapsible contents and update their buttons
            const nestedContents = content.querySelectorAll('.collapsible-content');
            const nestedButtons = content.querySelectorAll('.toggle-button');

            nestedContents.forEach(nested => {
                nested.style.display = newDisplay;
            });

            nestedButtons.forEach(nestedBtn => {
                nestedBtn.textContent = newLabel;
            });
        }

 
        function toggleAll() {
            const contents = document.querySelectorAll('.collapsible-content');
            const buttons = document.querySelectorAll('.toggle-button:not(#toggleAllBtn)');
            const toggleAllBtn = document.getElementById('toggleAllBtn');
            const shouldCollapse = toggleAllBtn.textContent === 'Collapse All';

            contents.forEach((content, index) => {
                    content.style.display = shouldCollapse ? 'none' : 'block';
                if (buttons[index]) {
                buttons[index].textContent = shouldCollapse ? 'Show' : 'Hide';
            }
        });


        toggleAllBtn.textContent = shouldCollapse ? 'Expand All' : 'Collapse All';
        }


        function toggleScript(button) {
            const pre = button.parentElement.querySelector('.script-body');
            const isVisible = pre.style.display !== 'none';
            pre.style.display = isVisible ? 'none' : 'block';
            button.textContent = isVisible ? 'Show' : 'Hide';
        }


        function copyScript(button) {
            const pre = button.parentElement.querySelector('.script-body');
            const text = pre.textContent;
            navigator.clipboard.writeText(text).then(() => {
                button.textContent = '✅';
                setTimeout(() => button.textContent = 'Copy', 1500);
            });
        }

    </script>
</head>
<body>
    <h1>$Title ⚙️</h1>
    <p>$headerSubText</p>
    <p>This report contains detailed information about Intune policies applied to devices and users.</p>
    <button class='toggle-button' onclick='toggleAll()' id='toggleAllBtn'>Collapse All</button>
"@


    $htmlFooter = "</body></html>"
    $htmlBody = ""
 
    $grouped = $Policies | Group-Object -Property PolicyScope

    $htmlBody += Get-DeviceInfoHTMLTables -GroupedPolicies $grouped

    $htmlBody += Get-DeviceAndUserHTMLTables -GroupedPolicies $grouped

    $htmlBody += Get-EnterpriseApplicationHTMLTables -GroupedPolicies $grouped

    $htmlBody += Get-ResourceHTMLTables -GroupedPolicies $grouped

    $htmlBody += Get-LAPSHTMLTables -GroupedPolicies $grouped 

    $htmlBody += Get-IntuneWin32AppTables

    $htmlBody += Get-IntuneScriptPolicyTables

    $fullHtml = $htmlHeader + $htmlBody + $htmlFooter

    Set-Content -Path $OutputPath -Value $fullHtml -Encoding UTF8
}
#endregion




#region MAIN SCRIPT EXECUTION
#$userInfoHash = Get-LocalUserInfo
# Lets cleanup any previous Intune report data
Invoke-IntuneReportDataCleanup -CleanUpDays $CleanUpDays

# Making the MDMDiagReportPath a script variable to be used in other functions
$script:MDMDiagReportPathVariable = $MDMDiagReportPath

$MDMDiagReportXml = Get-IntunePolicyDataFromXML -MDMDiagReportPath $MDMDiagReportPath
$MDMDiagReportHTMLPath = $MDMDiagReportXml.FileFullName -replace '.xml', '.html'

if (-Not (Test-Path -Path $MDMDiagReportHTMLPath))
{
    Write-Error "The specified MDM Diagnostics HTML Report file does not exist: `"$MDMDiagReportHTMLPath`""
    return
}

$script:MDMDiagHTMLReportPathVariable = $MDMDiagReportHTMLPath 

$script:enrollmentProviderIDs = Get-EnrollmentProviderIDs -MDMData $MDMDiagReportXml.XMlFileData

# Initialize a list to hold all Intune policies
$IntunePolicyList = [System.Collections.Generic.List[pscustomobject]]::new()

Get-IntunePolicySystemInfo -HtmlReportPath $MDMDiagReportHTMLPath | ForEach-Object {
    $IntunePolicyList.Add($_)
}

Get-IntuneDeviceAndUserPolicies -MDMData $MDMDiagReportXml.XMlFileData | ForEach-Object {
    $IntunePolicyList.Add($_)
}

Get-IntuneMSIPolicies -MDMData $MDMDiagReportXml.XMlFileData | ForEach-Object {
    $IntunePolicyList.Add($_)
}

Get-IntuneResourcePolicies -MDMData $MDMDiagReportXml.XMlFileData | ForEach-Object {
    $IntunePolicyList.Add($_)
}

Get-IntunePoliyLAPSData -MDMData $MDMDiagReportXml.XMlFileData | ForEach-Object {
    $IntunePolicyList.Add($_)
}

# name of the file to save the HTML report
$outFile = '{0}\IntunePolicyReport.html' -f (Split-Path -Path $MDMDiagReportHTMLPath -Parent)

# Convert the policies to HTML and save to the specified output path
Convert-IntunePoliciesToHtml -OutputPath $outFile -Policies $IntunePolicyList -Title "Intune Policy Report v4.0.1"

# Open the generated HTML report in Microsoft Edge
Start-Process "msedge.exe" -ArgumentList $outFile

