
<#
.Synopsis
    Script to create html report of Intune policies from MDM Diagnostics Report XML file.
 
.DESCRIPTION
    #************************************************************************************************************
    # Disclaimer
    #
    # This sample script is not supported under any Microsoft standard support program or service. This sample
    # script is provided AS IS without warranty of any kind. Microsoft further disclaims all implied warranties
    # including, without limitation, any implied warranties of merchantability or of fitness for a particular
    # purpose. The entire risk arising out of the use or performance of this sample script and documentation
    # remains with you. In no event shall Microsoft, its authors, or anyone else involved in the creation,
    # production, or delivery of this script be liable for any damages whatsoever (including, without limitation,
    # damages for loss of business profits, business interruption, loss of business information, or other
    # pecuniary loss) arising out of the use of or inability to use this sample script or documentation, even
    # if Microsoft has been advised of the possibility of such damages.
    #
    #************************************************************************************************************

    This script generates an HTML report of Intune policies from the MDM Diagnostics Report XML, HTML and AppWorkload.log files


.PARAMETER MDMDiagReportPath
    Path to the MDM Diagnostics export folder. 
    The folder should contain the MDMDiagReport.xml file, the MDMDiagReport.html file, and the IntuneManagementExtension AppWorkload.log files.
    If not provided, a new report of the system running the script on will be generated.

.PARAMETER CleanUpDays
    Number of days to keep the MDM Diagnostics report folders. Default is 1 day.
    Folders older than this number of days will be removed from the MDM Diagnostics folder.
    This parameter only applies to the report data generated by this script.

#>

[CmdletBinding()]
param 
(
    [Parameter(Mandatory = $false)]
    [string]$MDMDiagReportPath,

    [Parameter(Mandatory = $false)]
    [int]$CleanUpDays = 1
)

#region ConvertFrom-ObjectToCustomHtmlTable
function ConvertFrom-ObjectToCustomHtmlTable 
{
    [CmdletBinding()]
    param 
    (
        [object]$InputObjectList
    )


    foreach ($InputObject in $InputObjectList)
    {
        if ($null -eq $InputObject) 
        {
            return ''
        }

        if ($InputObject -is [System.Collections.IEnumerable] -and !$InputObject -is [string]) 
        {
            $items = @($InputObject)
            if ($items.Count -eq 0) 
            {
                return $null 
            }

            $headers = $items[0].PSObject.Properties.Name
            $rows = foreach ($item in $items) 
            {

                "<tr>" + ($headers | ForEach-Object { 
                    "<td>$(ConvertFrom-ObjectToCustomHtmlTable -InputObject $item.$_)</td>" 
                }) -join '' + "</tr>"
            }

            return "<table class='nested-table'><tr>" + ($headers | ForEach-Object { "<td>$_</td>" }) -join '' + "</tr>" + ($rows -join '') + "</table>"
        }
        elseif ($InputObject -is [psobject]) 
        {
            $rows = foreach ($prop in $InputObject.PSObject.Properties) 
            {
                "<tr><td>$($prop.Name)</td><td>$(ConvertFrom-ObjectToCustomHtmlTable -InputObject $prop.Value)</td></tr>"
            }

            return "<table class='nested-table'>" + ($rows -join '') + "</table>"
        }
        else 
        {
            # If we have a base 64 string, we will try to decode it
            if ($InputObject -match '^[A-Za-z0-9+/]*={0,2}$')
            {
                try 
                {
                    $decodedBytes = [System.Convert]::FromBase64String($InputObject)
                    $decodedString = [System.Text.Encoding]::UTF8.GetString($decodedBytes)
                    return "<pre>$decodedString</pre>"
                } 
                catch 
                {
                    return Invoke-EscapeHtmlText -Text ($InputObject.ToString())
                }
            }
            else 
            {
                return Invoke-EscapeHtmlText -Text ($InputObject.ToString())
            }        
        }
    }
}
#endregion


#region Get-IntuneOfficeInstallParams
Function Get-IntuneOfficeInstallParams
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [string]$ID
    )

    $basePath = "HKLM:SOFTWARE\Microsoft\OfficeCSP\$ID"

    try{$propertyValue = Get-ItemPropertyValue -Path $basePath -Name '(Default)' -ErrorAction SilentlyContinue }catch{}

    return $propertyValue
}
#endregion

#region Get-MDMFirewallSetting
Function Get-MDMFirewallSetting
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        [string]$Topic,
        [Parameter(Mandatory = $true)]
        [string]$SettingName
    )

    $basePath = "HKLM:SYSTEM\ControlSet001\Services\SharedAccess\Parameters\FirewallPolicy\Mdm"
    $topicPath = Join-Path -Path $basePath -ChildPath $Topic

    $propertyValue = $null
    if (-Not (Test-Path -Path $topicPath)) 
    {
        #Write-Error "The specified topic path does not exist: $topicPath"
        return $null
    }
    else 
    {
        try{$propertyValue = Get-ItemPropertyValue -Path $topicPath -Name $SettingName -ErrorAction SilentlyContinue }catch{}
    }

    return $propertyValue
}
#endregion


#region Get-CertificateDetailsByThumbprint
function Get-CertificateDetailsByThumbprint 
{
    param 
    (
        [Parameter(Mandatory = $true)]
        [string[]]$Thumbprints
    )

    [array]$certList = Get-ChildItem Cert:\LocalMachine -Recurse 

    $outList = [System.Collections.Generic.List[pscustomobject]]::new()
    foreach ($item in $thumbprints)
    {
        [array]$tmpCert = $certList | Where-Object { $_.Thumbprint -eq $item }
        if ($tmpCert) 
        {

            [array]$tmpStoreName = $tmpCert.pspath -replace '.*?Certificate::[^\\]+\\([^\\]+)\\.*', '$1' -replace 'CA', 'Intermediate CA' -replace 'Root', 'Root CA'

            $outList.Add([pscustomobject]@{
                Info = "Found in $($tmpStoreName.count) store(s)"
                Store = ($tmpStoreName -join ', ')
                Issuer = $tmpCert[0].Issuer -replace '^CN='
                IssuedTo = ($tmpCert[0].Subject -replace '^.*CN=([^,]+),.*$', '$1' -replace '^CN=')
                Thumbprint = $item
                ValidFrom = $tmpCert[0].NotBefore
                ValidTo = $tmpCert[0].NotAfter
                ExpireDays = try{[math]::Round(($tmpCert[0].NotAfter - (Get-Date)).TotalDays, 2)} catch { 'N/A' }
            })
        }
        else 
        {
            $outList.Add([pscustomobject]@{
                Info = 'Not found'
                Store = ''
                Issuer = ''
                IssuedTo = ''
                Thumbprint = $item
                ValidFrom = ''
                ValidTo = ''
                ExpireDays = ''
            })
        }
    }
    return $outList
}
#endregion


#region Get-IntunePoliyLAPSData
Function Get-IntunePoliyLAPSData
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        $MDMData
    )

    # https://learn.microsoft.com/en-us/windows/client-management/mdm/laps-csp
    $BackupDirectoryMap = @{
        0 = "0 - Disabled (password won't be backed up)" # Default
        1 = "1 - Backup the password to Microsoft Entra ID only"
        2 = "2 - Backup the password to Active Directory only"
    }

    $PasswordComplexityMap = @{
        1 = "1 - Large letters."
        2 = "2 - Large letters + small letters."
        3 = "3 - Large letters + small letters + numbers."
        4 = "4 - Large letters + small letters + numbers + special characters." # Default
        5 = "5 - Large letters + small letters + numbers + special characters (improved readability)."
        6 = "6 - Passphrase (long words)."
        7 = "7 - Passphrase (short words)."
        8 = "8 - Passphrase (short words with unique prefixes)."
    }

    $PostAuthenticationActionMap = @{
        1  = "1 - Reset password: upon expiry of the grace period, the managed account password will be reset."
        3  = "3 - Reset the password and logoff the managed account: upon expiry of the grace period, the managed account password will be reset and any interactive logon sessions using the managed account will be terminated." # Default
        5  = "5 - Reset the password and reboot: upon expiry of the grace period, the managed account password will be reset and the managed device will be immediately rebooted."
        11 = "11 - Reset the password, logoff the managed account, and terminate any remaining processes: upon expiration of the grace period, the managed account password is reset, any interactive logon sessions using the managed account are logged off, and any remaining processes are terminated."
    }

    $AutomaticAccountManagementTargetMap = @{
        0 = "0 - Automatically manage the built-in Administrator account"
        1 = "1 - Automatically manage a new custom account"
    }

    $AutomaticAccountManagementEnableAccountMap = @{
        0 = "0 - Disable the automatically managed account"
        1 = "1 - Enable the automatically managed account"
    }

    $AutomaticAccountManagementRandomizeNameMap = @{
        0 = "0 - Don't randomize the name of the automatically managed account"
        1 = "1 - Randomize the name of the automatically managed account"
    }

    # Initialize the output object
    $lapsOutObj = [pscustomobject][ordered]@{
        PolicyScope = 'LAPS'
        BackupDirectory = $null
        PasswordAgeDays = $null
        AutomaticAccountManagementEnabled = $null
        AutomaticAccountManagementNameOrPrefix = $null
        AutomaticAccountManagementEnableAccount = $null
        AutomaticAccountManagementTarget = $null
        AutomaticAccountManagementRandomizeName = $null
        PasswordComplexity = $null
        PostAuthenticationActions = $null
        PasswordLength = $null
        PostAuthenticationResetDelay = $null
        Local_LastAccountRidUpdated = $null
        Local_DSRMMode = $null
        Local_LastManagedAccountRid = $null
        Local_LastManagedAccountNameOrPrefix = $null
        Local_LastManagedAccountRandomizeName = $null
        Local_LastPasswordUpdateTime = $null
        Local_AzurePasswordExpiryTime = $null
        Local_PostAuthResetDeadline = $null
        Local_PostAuthResetAuthenticationTime = $null
        Local_PostAuthResetAccountSid = $null
        Local_PostAuthResetRetryCount = $null
        Local_PostAuthActions = $null
    }

    $LAPSData = $MDMData.MDMEnterpriseDiagnosticsReport.LAPS

    if (-NOT [string]::IsNullOrEmpty($LAPSData.Laps_CSP_Policy)) 
    {
        $lapsOutObj.BackupDirectory = try{$BackupDirectoryMap[[int]$LAPSData.Laps_CSP_Policy.BackupDirectory]}catch {$LAPSData.Laps_CSP_Policy.BackupDirectory}
        $lapsOutObj.PasswordAgeDays = $LAPSData.Laps_CSP_Policy.PasswordAgeDays
        $lapsOutObj.AutomaticAccountManagementEnabled = if($LAPSData.Laps_CSP_Policy.AutomaticAccountManagementEnabled -eq 1){"True"}else{"False"}
        $lapsOutObj.AutomaticAccountManagementNameOrPrefix = $LAPSData.Laps_CSP_Policy.AutomaticAccountManagementNameOrPrefix
        $lapsOutObj.AutomaticAccountManagementEnableAccount = try{$AutomaticAccountManagementEnableAccountMap[[int]$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementEnableAccount]}catch {$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementEnableAccount}
        $lapsOutObj.AutomaticAccountManagementTarget = try{$AutomaticAccountManagementTargetMap[[int]$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementTarget]}catch {$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementTarget}
        $lapsOutObj.AutomaticAccountManagementRandomizeName = try{$AutomaticAccountManagementRandomizeNameMap[[int]$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementRandomizeName]}catch {$LAPSData.Laps_CSP_Policy.AutomaticAccountManagementRandomizeName}
        $lapsOutObj.PasswordComplexity = try{$PasswordComplexityMap[[int]$LAPSData.Laps_CSP_Policy.PasswordComplexity]}catch {$LAPSData.Laps_CSP_Policy.PasswordComplexity}
        $lapsOutObj.PostAuthenticationActions = try{$PostAuthenticationActionMap[[int]$LAPSData.Laps_CSP_Policy.PostAuthenticationActions]}catch {$LAPSData.Laps_CSP_Policy.PostAuthenticationActions}
        $lapsOutObj.PasswordLength = $LAPSData.Laps_CSP_Policy.PasswordLength
        $lapsOutObj.PostAuthenticationResetDelay = $LAPSData.Laps_CSP_Policy.PostAuthenticationResetDelay
       
        if (-NOT [string]::IsNullOrEmpty($LAPSData.Laps_Local_State)) 
        {
            $lapsOutObj.Local_LastAccountRidUpdated = $LAPSData.Laps_Local_State.LastAccountRidUpdated
            $lapsOutObj.Local_DSRMMode = $LAPSData.Laps_Local_State.DSRMMode
            $lapsOutObj.Local_LastManagedAccountRid = $LAPSData.Laps_Local_State.LastManagedAccountRid
            $lapsOutObj.Local_LastManagedAccountNameOrPrefix = $LAPSData.Laps_Local_State.LastManagedAccountNameOrPrefix
            $lapsOutObj.Local_LastManagedAccountRandomizeName = $LAPSData.Laps_Local_State.LastManagedAccountRandomizeName
            $lapsOutObj.Local_LastPasswordUpdateTime = try{Convert-FileTimeToDateTime -FileTime $LAPSData.Laps_Local_State.LastPasswordUpdateTime} catch {$LAPSData.Laps_Local_State.LastPasswordUpdateTime}
            $lapsOutObj.Local_AzurePasswordExpiryTime = try{Convert-FileTimeToDateTime -FileTime $LAPSData.Laps_Local_State.AzurePasswordExpiryTime} catch {$LAPSData.Laps_Local_State.AzurePasswordExpiryTime}
            $lapsOutObj.Local_PostAuthResetDeadline = try{Convert-FileTimeToDateTime -FileTime $LAPSData.Laps_Local_State.PostAuthResetDeadline} catch {$LAPSData.Laps_Local_State.PostAuthResetDeadline}
            $lapsOutObj.Local_PostAuthResetAuthenticationTime = try{Convert-FileTimeToDateTime -FileTime $LAPSData.Laps_Local_State.PostAuthResetAuthenticationTime} catch {$LAPSData.Laps_Local_State.PostAuthResetAuthenticationTime}
            $lapsOutObj.Local_PostAuthResetAccountSid = $LAPSData.Laps_Local_State.PostAuthResetAccountSid
            $lapsOutObj.Local_PostAuthResetRetryCount = $LAPSData.Laps_Local_State.PostAuthResetRetryCount
            $lapsOutObj.Local_PostAuthActions = $LAPSData.Laps_Local_State.PostAuthActions
        }

        return $lapsOutObj   
    }
}
#endregion


#region ConvertTo-HTMLTableFromArray 
Function ConvertTo-HTMLTableFromArray 
{
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [array]$InputList
    )

    $htmlOutput = ""

    foreach ($item in $InputList) 
    {
        $htmlOutput += "<table style='border-collapse: collapse; border: none; margin-bottom: 1em;'>"
        foreach ($prop in $item.PSObject.Properties) 
        {
            $htmlOutput += "<tr style='border: none;'>"
            $htmlOutput += "<td style='padding: 2px 8px; font-weight: bold; border: none; vertical-align: top; width: 200px;'>$($prop.Name)</td>"
            $htmlOutput += "<td style='padding: 2px 8px; border: none;'>$($prop.Value)</td>"
            $htmlOutput += "</tr>"
        }

        $htmlOutput += "</table>"
        $htmlOutput += "<br>"
    }
    
    return $htmlOutput
}
#endregion


#region ConvertTo-HTMLListFromArray
Function ConvertTo-HTMLListFromArray
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
        [array]$InputList      
    )

    $maxLength = ($InputList | ForEach-Object {
        $_.PSObject.Properties | ForEach-Object { $_.Name.Length }
        } | Measure-Object -Maximum).Maximum

    $outString = ''
    foreach ($item in $InputList)
    {
        foreach ($prop in $item.PSObject.Properties) 
        {
            $dots = '.' * ($maxLength - $prop.Name.Length + 2)  # +2 for spacing

            $outString += '{0}{1}: {2}<br>' -f $prop.Name, $dots, $($prop.Value)
        }
        $outString += "<br>"  # Extra line between objects
    }

    return $outString
}
#endregion


#region Invoke-IntuneReportDataCleanup
Function Invoke-IntuneReportDataCleanup
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $false)]
        [int]$CleanUpDays = 1
    )

    $MDMDiagFolder = "$env:PUBLIC\Documents\MDMDiagnostics"

    if (-NOT (Test-Path -Path $MDMDiagFolder)) 
    {
        return # nothing to cleanup
    }
    else 
    {
        # Get all folders with names in the format of 'yyyy-MM-dd_HH-mm-ss'
        [array]$folderList = Get-ChildItem -Path $MDMDiagFolder -Directory | Where-Object { $_.Name -match '^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}$' }

        # now cleanup the folders that are older than the specified number of days based on their name
        foreach ($folder in $folderList) 
        {
            # Get the folder creation time
            $folderCreationTime = [datetime]::ParseExact($folder.Name, 'yyyy-MM-dd_HH-mm-ss', $null)

            # Check if the folder is older than the specified number of days
            if ($folderCreationTime -lt (Get-Date).AddDays(-$CleanUpDays)) 
            {
                # Remove the folder and its contents
                Write-Host "Removing old policy report folder: $($folder.FullName)"
                Remove-Item -Path $folder.FullName -Recurse -Force -ErrorAction SilentlyContinue
            }
        }
    }
}
#endregion


#region Get-MSIProductCodesWithNames
function Get-MSIProductCodesWithNames 
{
    $results = @()

    $registryPaths = @(
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    )

    foreach ($path in $registryPaths) 
    {
        if (Test-Path $path) {
            Get-ChildItem -Path $path | ForEach-Object {
                $key = $_
                $productCode = $key.PSChildName

                if ($productCode -match '^\{[0-9A-F\-]{36}\}$') 
                {
                    $props = Get-ItemProperty -Path $key.PSPath -ErrorAction SilentlyContinue
                    $displayName = $props.DisplayName

                    $results += [PSCustomObject]@{
                        ProductCode = $productCode
                        Name        = $displayName
                    }

                }
            }
        }
    }
    return $results
}
#endregion


#region Get-IntunePolicyDataFromXML
Function Get-IntunePolicyDataFromXML
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $false)]
        [string]$MDMDiagReportPath
    )

    # If no path is provided, generate a new report
    if ([string]::IsNullOrEmpty($MDMDiagReportPath)) 
    {
        $MDMDiagFolder = "$env:PUBLIC\Documents\MDMDiagnostics\$(Get-date -Format 'yyyy-MM-dd_HH-mm-ss')"

        if (-NOT (Test-Path -Path $MDMDiagFolder)) 
        {
            New-Item -Path $MDMDiagFolder -ItemType Directory | Out-Null
        }

        $MDMDiagReportXmlPath = '{0}\MDMDiagReport.xml' -f $MDMDiagFolder

        Start-Process MdmDiagnosticsTool.exe -Wait -ArgumentList "-out `"$MDMDiagFolder`"" -NoNewWindow -ErrorAction Stop

        [xml]$xmlFile = Get-Content -Path $MDMDiagReportXmlPath -Raw -ErrorAction Stop
    }
    else 
    {
        if (-Not (Test-Path -Path $MDMDiagReportPath)) 
        {
            Write-Error "The specified MDM Diagnostics path does not exist: `"$MDMDiagReportPath`""
            return
        }

        $MDMDiagReportXmlPath = '{0}\MDMDiagReport.xml' -f $MDMDiagReportPath

        if (-Not (Test-Path -Path $MDMDiagReportXmlPath))
        {
            Write-Error "The specified MDM Diagnostics Report XML file does not exist: `"$MDMDiagReportXmlPath`""
            return
        }
        [xml]$xmlFile = Get-Content -Path $MDMDiagReportXmlPath -Raw -ErrorAction Stop
    }

    $outObj = [pscustomobject]@{
        XMlFileData = $xmlFile
        FileFullName = $MDMDiagReportXmlPath
    }
    return $outObj
}
#endregion


#region Get-IntunePolicySystemInfo
# Extract system information from the MDM Diagnostics Report
Function Get-IntunePolicySystemInfo
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        [string]$HtmlReportPath
    )

    if (-not (Test-Path -Path $HtmlReportPath)) 
    {
        # Lets thest for a different file name
        # This might be the case if the report was generated with the settings app or the MDM Diagnostics Tool with differnt parameters
        # MDMDiagHTMLReport.html
        $HtmlReportPath = $HtmlReportPath -replace 'MDMDiagReport\.html', 'MDMDiagHTMLReport.html'
    }

    $htmlFile = Get-Content -Path $HtmlReportPath -Raw -ErrorAction SilentlyContinue

    $tablePattern = '<table[^>]*id="(?:DeviceInfoTable|ConnectionInfoTable)"[^>]*>(.*?)<\/table>'
    $tableMatches = [regex]::Matches($htmlFile, $tablePattern, 'Singleline')

    $properties = @{} 
    
    $outObj = [pscustomobject][ordered]@{
                    DeviceName = $null
                    Organization = $null
                    Edition = $null
                    OSBuild = $null
                    Processor = $null
                    #InstalledRAM = $null
                    SystemType = $null
                    #ManagedBy = $null
                    LastSync = $null
                    ManagementServerAddress = $null
                    ExchangeID = $null
                    ActiveSID = $null
                    ActiveAccount = $null
                    UserToken = $null
                    PolicyScope = 'DeviceInfo'
                }

    foreach($tableMatch in $tableMatches)
    {
        $rowPattern = '"LabelColumn">(?<Label>.*?)</td><td.*?>(?<Value>.*?)</td>'
        $valueResults = [regex]::Matches($tableMatch, $rowPattern)

        
        foreach($item in $valueResults)
        {
            $labelObj = $item.Groups | Where-Object -Property Name -eq 'Label'
            $valueObj = $item.Groups | Where-Object -Property Name -eq 'Value'

            $properties[$labelObj.Value] = $valueObj.Value
        }
    }

    $tmpObj = [PSCustomObject]$properties
    try 
    {
        $outObj.DeviceName = $tmpObj.'PC name'
        $outObj.Organization = $tmpObj.'Organization'
        $outObj.Edition = $tmpObj.'Edition'
        $outObj.OSBuild = $tmpObj.'OS Build'
        $outObj.Processor = $tmpObj.'Processor'
        #$outObj.InstalledRAM = $tmpObj.'Installed RAM'
        $outObj.SystemType = $tmpObj.'System Type'
        #$outObj.ManagedBy = $tmpObj.'Managed By'
        $outObj.LastSync = $tmpObj.'Last Sync'
        $outObj.ManagementServerAddress = $tmpObj.'Management Server Address'
        $outObj.ExchangeID = $tmpObj.'Exchange ID'
        $outObj.ActiveSID = $tmpObj.'Active SID'
        $outObj.ActiveAccount = $tmpObj.'Active Account'
        $outObj.UserToken = $tmpObj.'User Token'

        if ($outObj.OSBuild -gt 10.0.19045) 
        {
            $outObj.Edition = $outObj.Edition -replace 'Windows 10', 'Windows 11'
        }

        # lets remove the word unknown from the systemtype if it is present
        $outObj.SystemType = ($outObj.SystemType -replace 'Unknown', '') -replace '^\s+',''     
    }
    catch {}

    return $outObj
}
#endregion


#region Get-IntuneDeviceAndUserPolicies
Function Get-IntuneDeviceAndUserPolicies
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        $MDMData
    )

    $userInfoHash = Get-LocalUserInfo

    $outObj = [System.Collections.Generic.List[pscustomobject]]::new()
    # Iterate through each ConfigSource item in the XML
    foreach ($item in $MDMData.MDMEnterpriseDiagnosticsReport.PolicyManager.ConfigSource)
    {
        $global:test = $item

        $enrollmentID = $item.EnrollmentId
        
        foreach ($PolicyScope in $item.PolicyScope)
        {
            $PolicyScopeName = $PolicyScope.PolicyScope

            foreach ($area in $PolicyScope.Area)
            {
                if ($area.PolicyAreaName -ieq 'knobs')
                {
                    # Skip the 'knobs' area
                    continue
                }

                # Define the properties we are interested in 
                [array]$propertyList = $area | Get-Member | Where-Object {$_.MemberType -eq 'Property'} | Select-Object -Property Name | Where-Object {$_.Name -notlike '*_LastWrite' -and $_.Name -ne 'PolicyAreaName'}


                try{$enrollmentProvider = $script:enrollmentProviderIDs[$enrollmentID]}catch{}
                if([string]::IsNullOrEmpty($enrollmentProvider))
                {
                    $enrollmentProvider = 'Unknown'
                }

                try{$userName = $userInfoHash[$PolicyScopeName]}catch{}
                if([string]::IsNullOrEmpty($userName))
                {
                    $userName = 'Unknown'
                }

                $tmpObj = [pscustomobject]@{
                                EnrollmentId = $enrollmentID
                                EnrollmentProvider = $enrollmentProvider
                                PolicyScope  =  $PolicyScopeName
                                PolicyScopeDisplay = if ($PolicyScopeName -eq 'Device') { $PolicyScopeName } else { $userName }
                                PolicyAreaName = $area.PolicyAreaName
                                SettingsCount = $propertyList.Count
                                Settings = ""
                            }

                $settingsList = [System.Collections.Generic.List[pscustomobject]]::new()
                foreach ($property in $propertyList)
                {

                    # Adding metadata for the property
                    $metadataInfo = Get-IntunePolicyMetadata -MDMData  $MDMData -PolicyAreaName $area.PolicyAreaName -PolicyName $property.Name
                    if ($area.PolicyAreaName -ieq 'knobs')
                    {
                        $winningProvider = "Not set"
                    }
                    else 
                    {
                        $currentPolicyInfo = Get-IntunePolicyCurrentData -PolicyScope $PolicyScopeName -PolicyAreaName $area.PolicyAreaName -PolicyName $property.Name -MDMData $MDMData
                        if ($null -eq $currentPolicyInfo)
                        {
                            $winningProvider = "Not set"    
                        }
                        else 
                        {
                            $winningProvider = $currentPolicyInfo | Select-Object -ExpandProperty "$($property.Name)_WinningProvider"
                        }
                    }                    

                    $settingsList.Add([pscustomobject][ordered]@{
                        Name = $property.Name
                        Value = $area.$($property.Name)
                        WinningProvider = $winningProvider
                        Metadata = $metadataInfo
                    })
                }

                $tmpObj.Settings = $settingsList   
                
                # Add the tmpObj to the $outObj
                $outObj.Add($tmpObj)
            }
        }
    }

    return $outObj
}
#endregion


#region Get-IntuneWin32AppPolicies
function Get-IntuneWin32AppPolicies
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $false)]
        [string]$LogPath
    )

    $statusList = [System.Collections.Generic.List[pscustomobject]]::new()

    # check if the script is running with administrative privileges
    if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))
    {
        if ([string]::IsNullOrEmpty($script:MDMDiagReportPathVariable))
        {
            # The message does only makes sense if the script is run locally without the MDMDiagReportPath parameter
            Write-Host "To get a more detailed Win32App report run the script with administrative permissions" -ForegroundColor Yellow
        }
    }
    else
    {
        [array]$win32AppStatusServiceReports = Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\IntuneManagementExtension\SideCarPolicies\StatusServiceReports"
        
        foreach ($report in $win32AppStatusServiceReports)
        {

            $identityID = $report.Name | Split-Path -Leaf -ErrorAction SilentlyContinue

            $assignedTo = if ($identityID -eq '00000000-0000-0000-0000-000000000000'){'Device'}else{$identityID}
            [array]$reportData = Get-ChildItem -Path $report.PSPath

            foreach ($dataItem in $reportData)
            {
                # adding some symbols
                $tmpApplicabilityCode = $dataItem.GetValue("ApplicabilityCode")
                if ($tmpApplicabilityCode -eq 'Applicable'){$tmpApplicabilityCode = '✅ Applicable'}else{$tmpApplicabilityCode = '❌ {0}' -f $tmpApplicabilityCode}
                
                $tmpStatus = $dataItem.GetValue("Status")
                if ($tmpStatus -eq 'Installed'){$tmpStatus = '✅ Installed'}else{$tmpStatus = '❌ {0}' -f $tmpStatus}

                $tmpObj = [pscustomobject][ordered]@{
                    AssignedTo         = $assignedTo
                    AppId              = $dataItem.GetValue("AppId")
                    ApplicabilityCode  = $tmpApplicabilityCode
                    ApplicabilityCode2 = $dataItem.GetValue("ApplicabilityCode2")
                    CustomError        = $dataItem.GetValue("CustomError")
                    Required           = $dataItem.GetValue("Required")
                    Status             = $tmpStatus
                    Status2            = $dataItem.GetValue("Status2")
                    ErrorCode          = $dataItem.GetValue("ErrorCode")
                }

                $statusList.Add($tmpObj)            
            }
        }
    }
    

    if ([string]::IsNullOrEmpty($LogPath))
    {
        # Default log path for Win32 App Management logs
        $LogPath = "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\AppWorkload*.log"
    }       

    # Getting all AppWorkload and sorting them by LastWriteTime
    # This will make sure we have the latest entries at the first position in our array by sorting files descending
    $logFiles = Get-ChildItem -Path $LogPath | Sort-Object -Property LastWriteTime -Descending

    # win32app policy string pattern
    $pattern = '<!\[LOG\[Get policies = \[\{(.*)\]LOG\]!>'

    # Get all policies with regex pattern filter
    $lines = $logFiles | Select-String -Pattern $pattern

    if ($lines)
    {
        $appList = @()
        Foreach ($line in $lines[0])
        {
            # We need to add the chars "[{" to the beginning of the line to make it a valid JSON array 
            # since we made the not part of the regex pattern to only match policies with at least one app
            [array]$appList += "[{$($line.Matches.Groups[1].Value)" | ConvertFrom-Json
        }
    }
    else 
    {
        return @()
    }

    # add property
    foreach ($app in $appList)
    {
        # Set to default value
        $app | Add-Member -MemberType NoteProperty -Name 'AppState' -Value @()       
    }


    if ($statusList.count -gt 0)
    {
        foreach ($app in $appList)
        {
            [array]$appState = $statusList | Where-Object -Property 'AppID' -EQ ($app.Id) | Select-Object AssignedTo, ApplicabilityCode, Required, Status, ErrorCode
            if ($appState.count -gt 0)
            {
                $app.AppState = $appState
            }
        }
    }

    return ($appList | Sort-Object -Property Name)
}
#endregion


#region Get-LocalUserInfo
function Get-LocalUserInfo 
{
    $userHashTable = @{}

    Get-ChildItem 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList' |
    ForEach-Object {
        $sid = $_.PSChildName
        try 
        {
            $profilePath = (Get-ItemProperty $_.PSPath).ProfileImagePath
            $username = Split-Path -Leaf $profilePath
            $userHashTable[$sid] = $username
        } catch {
            $userHashTable[$sid] = 'Unknown'
        }
    }

    return $userHashTable
}
#endregion


#region Get-IntuneResourcePolicies
function Get-IntuneResourcePolicies
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        $MDMData
    )


    $outList = [System.Collections.Generic.List[pscustomobject]]::new()
    foreach ($enrollment in $MDMData.MDMEnterpriseDiagnosticsReport.Resources.Enrollment)
    {
        $enrollmentID = $enrollment.enrollmentid

        foreach ($scope in $enrollment.Scope)
        {
            $resourceTarget = $scope.ResourceTarget
            #$scope.ChildNodes.'#Text'
            foreach ($resource in $scope.Resources.ChildNodes.'#Text')
            {
                # Setting $matches to null to avoid issues with previous matches
                $matches = $null
                if (($resource -match '^\d+$') -or ($resource -match '^default$'))
                {
                    continue
                }

                # Setting $matches to null to avoid issues with previous matches
                $matches = $null
                $tmpResourceType = 'Unknown'
                if ($resource -match "Vendor/[^/]+/([^/]+)") 
                {
                    $tmpResourceType = $matches[1]
                }

                $tmpCertObj = [pscustomobject]@{
                    CertStore = $null
                    Issuer = $null
                    IssuedTo = $null
                    Thumbprint = $null
                    ValidFrom = $null
                    ValidTo = $null
                    ExpireDays = $null
                }

                # running locally?
                $tmpSubject = ''
 
                $boolCertResource = $false
                switch -Regex ($resource) 
                {
                    'RootCATrustedCertificates\/Root' 
                    {
                        $certPath = "Cert:\{0}\Root\{1}"
                        $certStoreName = 'Root CA'
                        $boolCertResource = $true
                    }

                    'RootCATrustedCertificates\/CA'
                    {
                        $certPath = "Cert:\{0}\CA\{1}"
                        $certStoreName = 'Intermediate CA'
                        $boolCertResource = $true
                    }
                    'RootCATrustedCertificates\/TrustedPublisher' 
                    {
                        $certPath = "Cert:\{0}\TrustedPublisher\{1}"
                        $certStoreName = 'Trusted Publisher'
                        $boolCertResource = $true
                    }
                }

                if($boolCertResource)
                {
                    # Determine the certificate store type based on the resource path
                    switch -Regex ($resource) 
                    {
                        '^\.\/device\/' { $tmpPathType = 'LocalMachine'; break }
                        '^\.\/user\/'   { $tmpPathType = 'CurrentUser'; break }
                        default         { $tmpPathType = 'LocalMachine' }
                    }
                
                    # Lets get the certificate details by thumbprint
                    $tmpThumbprint = $resource | Split-Path -Leaf -ErrorAction SilentlyContinue
                    # Addind the middle part to the path string at the thumbprint at the end
                    $certPath = $certPath -f $tmpPathType, $tmpThumbprint

                    if (Test-Path $certPath) 
                    {
                        # Looking for a cert locally
                        [array]$cert = Get-Item -Path "$certPath" -ErrorAction SilentlyContinue
                    }
                    if ($cert) 
                    {
                        $resource = '{0} ➡️ {1}' -f $resource,  ($cert.Subject -replace '^.*CN=([^,]+),.*$', '$1' -replace '^CN=')
                        $tmpCertObj.CertStore = $certStoreName
                        $tmpCertObj.IssuedTo = ($cert.Subject -replace '^.*CN=([^,]+),.*$', '$1' -replace '^CN=')
                        $tmpCertObj.Issuer = $cert.Issuer -replace '^CN='
                        $tmpCertObj.Thumbprint = $tmpThumbprint
                        $tmpCertObj.ValidFrom = $cert.NotBefore.ToString("yyyy-MM-dd HH:mm:ss")
                        $tmpCertObj.ValidTo = $cert.NotAfter.ToString("yyyy-MM-dd HH:mm:ss")
                        $tmpCertObj.ExpireDays = try{[math]::Round(($cert.NotAfter - (Get-Date)).TotalDays, 2)} catch { 'N/A' }
                    }
                    else 
                    {
                        $resource = '{0} ➡️ {1}' -f $resource,  ($cert.Subject -replace '^.*CN=([^,]+),.*$', '$1' -replace '^CN=')
                        $tmpCertObj.CertStore = $certStoreName
                        $tmpCertObj.IssuedTo = $null
                        $tmpCertObj.Issuer = $null
                        $tmpCertObj.Thumbprint = $tmpThumbprint
                        $tmpCertObj.ValidFrom = $null
                        $tmpCertObj.ValidTo = $null
                        $tmpCertObj.ExpireDays = $null                  
                    }
                }
                
                # Putting it all together
                $outObj = [pscustomobject]@{
                    PolicyScope = 'Resource'
                    EnrollmentId = $enrollmentID
                    ProviderID = (Get-EnrollmentIDData -EnrollmentId $enrollmentID -MDMData $MDMData).ProviderID
                    ResourceTarget = $resourceTarget
                    ResourceName = $resource
                    ResourceType = $tmpResourceType    
                    ResourceData = if($boolCertResource){$tmpCertObj}else{$null}
                }
                $outList.Add($outObj)
            }
            
        }
    }
    return $outList
}
#endregion


#region Convert-FileTimeToDateTime 
function Convert-FileTimeToDateTime 
{
    param 
    (
        [Parameter(Mandatory = $true)]
        [UInt64]$FileTime
    )

    $seconds = $FileTime / 10000000

    # FILETIME epoch starts at January 1, 1601 (UTC)
    # PowerShell 5.1 doesn't support -AsUTC, so use DateTime with Kind set to UTC
    $epoch = [DateTime]::SpecifyKind([DateTime]::Parse("1601-01-01T00:00:00"), [DateTimeKind]::Utc)

    # Add the seconds to the epoch
    $datetime = $epoch.AddSeconds($seconds)

    # Format the output
    return $datetime.ToString("yyyy-MM-dd HH:mm:ss")
}
#endregion


#region Get-IntuneMSIPolicies
Function Get-IntuneMSIPolicies
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        $MDMData
    )


    $StatusCodes = @{
        10 = "⚙️ Initialized"
        20 = "⬇️ Download In Progress"
        25 = "🔁 Pending Download Retry"
        30 = "❌ Download Failed"
        40 = "✅ Download Completed"
        48 = "🧑‍💻 Pending User Session"
        50 = "⚙️ Enforcement In Progress"
        55 = "🔁 Pending Enforcement Retry"
        60 = "🚫 Enforcement Failed"
        70 = "✅ Enforcement Completed"
    }



    $outList = [System.Collections.Generic.List[pscustomobject]]::new()
    Foreach ($user in $MDMData.MDMEnterpriseDiagnosticsReport.EnterpriseDesktopAppManagementinfo.MsiInstallations.TargetedUser)
    {
        $assignmentIdentity = if($user.UserSID -eq 'S-0-0-00-0000000000-0000000000-000000000-000'){'Device'}else{$user.UserSID}
        
        foreach ($package in $user.Package)
        {
            foreach ($packageDetail in $package.Details)
            {  

                if ([string]::IsNullOrEmpty($packageDetail.CurrentDownloadUrl))
                {
                    $possibleAppName = 'Unknown'    
                }
                else 
                {
                    $possibleAppName = ($packageDetail.CurrentDownloadUrl | Split-Path -Leaf -ErrorAction SilentlyContinue)
                }

                # A specifc order helps to keep the output consistent and easier to find information
                $outObj = [PSCustomObject][ordered]@{
                    PossibleAppName = $possibleAppName
                    AssignmentIdentity = $assignmentIdentity
                    Status = $packageDetail.Status
                    LastError = $packageDetail.LastError
                    ProductVersion = $packageDetail.ProductVersion
                    ProductCode = $packageDetail.ProductCode
                    CreationTime = $packageDetail.CreationTime
                    EnforcementStartTime = $packageDetail.EnforcementStartTime
                    CurrentDownloadUrl = $packageDetail.CurrentDownloadUrl
                    CommandLine = $packageDetail.CommandLine
                    DownloadLocation = $packageDetail.DownloadLocation
                    DownloadInstall = $packageDetail.DownloadInstall
                    EnforcementRetryCount = $packageDetail.EnforcementRetryCount
                    EnforcementRetryIndex = $packageDetail.EnforcementRetryIndex
                    EnforcementRetryInterval = $packageDetail.EnforcementRetryInterval
                    EnforcementTimeout = $packageDetail.EnforcementTimeout
                    FileHash = $packageDetail.FileHash
                    LocURI = $packageDetail.LocURI
                    ActionType = $packageDetail.ActionType
                    AssignmentType = $packageDetail.AssignmentType
                    BITSJobId = $packageDetail.BITSJobId
                    JobStatusReport = $packageDetail.JobStatusReport
                    ServerAccountID = $packageDetail.ServerAccountID
                    PackageId = $packageDetail.PackageId
                    PackageType = 'MSI'
                    PolicyScope = 'EnterpriseDesktopAppManagement'                    
                }

                try 
                {
                    $tmpCreationTime = Convert-FileTimeToDateTime -FileTime $outObj.CreationTime   
                    $outObj.CreationTime = $tmpCreationTime
                }
                catch {
                    Write-Host "Failed to convert CreationTime for package: $($outObj.PackageId). Error: $_"
                }

                try 
                {
                    $tmpEnforcementStartTime = Convert-FileTimeToDateTime -FileTime $outObj.EnforcementStartTime   
                    $outObj.EnforcementStartTime = $tmpEnforcementStartTime
                }
                catch {
                    Write-Host "Failed to convert EnforcementStartTime for package: $($outObj.PackageId). Error: $_"
                }
                # Convert the status code to a human-readable string
                try
                {
                    $tmpStatus = $StatusCodes[[int]($outObj.Status)]
                    $outObj.Status = $tmpStatus
                }catch{}
                 

                $outList.Add($outObj)
            }
        }      
    }

    $outListSorted = $outList | Sort-Object -Property PossibleAppName, CreationTime -Descending

    return $outListSorted
}
#endregion


#region Get-IntunePolicyCurrentData
Function Get-IntunePolicyCurrentData
{
    param 
    (
        [Parameter(Mandatory = $true)]
        [string]$PolicyScope,
        [Parameter(Mandatory = $true)]
        [string]$PolicyAreaName,
        [Parameter(Mandatory = $true)]
        [string]$PolicyName,
        [Parameter(Mandatory = $true)]
        $MDMData
    )
    
    # Define the policy scope to filter by
    [array]$global:PolicyScopeData = $MDMData.MDMEnterpriseDiagnosticsReport.PolicyManager.currentPolicies | Where-Object { $_.PolicyScope -eq $PolicyScope }

    # Search for the specific policy area and policy name
    $PolicyObj = $PolicyScopeData.CurrentPolicyValues | Where-Object { $_.PolicyAreaName -eq $PolicyAreaName} 

    # Looking for the specific policy name
    $resultObj = $PolicyObj | select-object -Property "$($PolicyName)_ProviderSet", "$($PolicyName)_WinningProvider"

    return $resultObj
}
#endregion


#region Get-IntunePolicyMetadata
function Get-IntunePolicyMetadata
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        [string]$PolicyAreaName,
        [Parameter(Mandatory = $true)]
        [string]$PolicyName,
        [Parameter(Mandatory = $true)]
        $MDMData
    )

    $outObj = [pscustomobject]@{
        RedirectionPath = "Redirection path not set"
        DefaultValue = "No default value set"
    }

    # PolicymetaData is a collection of metadata for each policy 
    # We are interested in the regpah or translationDllPath for the specific policy
    $policyMetaData = $MDMData.MDMEnterpriseDiagnosticsReport.PolicyManagerMeta.AreaMetadata | Where-Object { $_.PolicyAreaName -eq $PolicyAreaName }
    if (-not $policyMetaData) 
    {
        return $outObj
    }
    else 
    {
        $policy = $policyMetaData.PolicyMetadata | Where-Object { $_.PolicyName -eq $PolicyName } 
        if (-not $policy) 
        {
            return $outObj
        }
        else 
        {
            if (-NOT ([string]::IsNullOrEmpty($policy.value))) 
            {
                # If the policy has a value, return it as the default value
                $outObj.DefaultValue = $policy.value
            }

            # If the policy has a RegKeyPathRedirect, return it
            if (-NOT ([string]::IsNullOrEmpty($policy.RegKeyPathRedirect))) 
            {
                $outObj.RedirectionPath = 'RegKeyPathRedirect: {0}' -f $policy.RegKeyPathRedirect
            }

            # If the policy has a translationDllPath, return it
            if(-not ([string]::IsNullOrEmpty($policy.translationDllPath)))
            {
                $outObj.RedirectionPath = 'TranslationDllPath: {0}' -f $policy.translationDllPath
            }

            # If the policy has a grouppolicyPath, return it
            if(-not ([string]::IsNullOrEmpty($policy.grouppolicyPath)))
            {
                $outObj.RedirectionPath = 'GroupPolicyPath: {0}' -f $policy.grouppolicyPath
            }   

            # precheckDllPath
            if(-not ([string]::IsNullOrEmpty($policy.precheckDllPath)))
            {
                $outObj.RedirectionPath = 'PrecheckDllPath: {0}' -f $policy.precheckDllPath
            }

            # GPBlockingRegKeyPath
            if(-not ([string]::IsNullOrEmpty($policy.GPBlockingRegKeyPath)))
            {
                $outObj.RedirectionPath = 'GPBlockingRegKeyPath: {0}' -f $policy.GPBlockingRegKeyPath
            }
        }
    }
    return $outObj
}
#endregion


#region Get-EnrollmentIDData
function Get-EnrollmentIDData
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        [string]$EnrollmentId,
        [Parameter(Mandatory = $true)]
        $MDMData
    )

    $enrollmentObj = $MDMData.MDMEnterpriseDiagnosticsReport.Enrollments.Enrollment | Where-Object {$_.EnrollmentId -eq $EnrollmentId} 
    # If no enrollment object is found, return null
    if (-not $enrollmentObj) 
    {
        #Write-Error "Enrollment ID '$EnrollmentId' not found."
        return $null
    }
    else
    {
        return [pscustomobject][ordered]@{
            EnrollmentId = $enrollmentObj.EnrollmentId
            EnrollmentState = $enrollmentObj.EnrollmentState
            EnrollmentType = $enrollmentObj.EnrollmentType
            CurCryptoProvider = $enrollmentObj.CurCryptoProvider
            DiscoveryServiceFullURL = $enrollmentObj.DiscoveryServiceFullURL
            DMServerCertificateThumbprint = $enrollmentObj.DMServerCertificateThumbprint
            IsFederated = $enrollmentObj.IsFederated
            ProviderID = if ($null -eq $enrollmentObj.ProviderID) 
            {
                'Local'
            }
            elseif ($enrollmentObj.ProviderID -eq 'MS DM Server') 
            {
                'Intune'
            }
            else
            {
                $enrollmentObj.ProviderID
            }

            RenewalPeriod = $enrollmentObj.RenewalPeriod
            RenewalErrorCode = $enrollmentObj.RenewalErrorCode
            RenewalROBOSupport = $enrollmentObj.RenewalROBOSupport
            RenewalStatus = $enrollmentObj.RenewalStatus
            RetryInterval = $enrollmentObj.RetryInterval
            RootCertificateThumbPrint = $enrollmentObj.RootCertificateThumbPrint
            IsRecoveryAllowed = $enrollmentObj.IsRecoveryAllowed
            DMClient = $enrollmentObj.DMClient
            Poll = $enrollmentObj.Poll
            FirstSync = $enrollmentObj.FirstSync
            UserFirstSync = $enrollmentObj.UserFirstSync
            Push = $enrollmentObj.Push
        }
    }
}
#endregion


#region Get-EnrollmentProviderIDs
function Get-EnrollmentProviderIDs
{
    [CmdletBinding()]
    param 
    (
        [Parameter(Mandatory = $true)]
        $MDMData
    )
    
    $enrollmentHashTable = @{}
    foreach($enrollment in $MDMData.MDMEnterpriseDiagnosticsReport.Enrollments.Enrollment)
    {
        $providerID = $enrollment.ProviderID
        if ($enrollment.EnrollmentId -match '[a-fA-F0-9\-]{36}')
        {
            If([string]::IsNullOrEmpty($enrollment.ProviderID))
            {
                $providerID = 'Local'
            }
            elseif ($enrollment.ProviderID -eq 'MS DM Server')
            {
                $providerID = 'Intune'
            }
            $enrollmentHashTable[$enrollment.EnrollmentId] = $providerID
        }
        else 
        {
            # If the EnrollmentId is not in the expected format, skip it
            continue
        }
    }

    return $enrollmentHashTable
}
#endregion


#region Invoke-EscapeHtmlText
function Invoke-EscapeHtmlText 
{
    param 
    (
        [string]$Text
    )

    try 
    {
        return [System.Web.HttpUtility]::HtmlEncode($Text)  
    }
    catch 
    {
        return $Text -replace '&', '&amp;' `
                    -replace '<', '&lt;' `
                    -replace '>', '&gt;' `
                    -replace '"', '&quot;' `
                    -replace "'", '&#39;'
    }
}
#endregion


#region Get-DeviceAndUserHTMLTables
Function Get-DeviceAndUserHTMLTables
{
    param
    (
        [Parameter(Mandatory = $true)]
        [array]$GroupedPolicies
    )

    $htmlBody = ""
    $selection = $GroupedPolicies.Where({($_.Name -eq 'Device') -or ($_.Name -match 'S-\d+(-\d+)+')})
    $deviceSelection = $GroupedPolicies.Where({ $_.Name -eq 'Device' })
    #$userSelection = $GroupedPolicies.Where({ $_.Name -match 'S-\d+(-\d+)+' })
    foreach ($group in $selection) 
    {
        if ($group.Name -eq 'Device') 
        { 
            $statString = "TotalPolicyAreas: {0}<br>TotalSettings: {1}" -f $deviceSelection.group.count, $deviceSelection.group.Settings.count
            $areaTitleString = '💻 Device'
        } 
        else 
        { 
            # We need to get the right numbers per user, not for all users together
            [array]$tmpUserStatsSelection = $GroupedPolicies.Where({ $_.Name -eq $group.Name})
            $tmpTotalAreas = 0
            $tmpTotalAreas = try{($tmpUserStatsSelection | Select-Object -Property Count).Count}catch{}
            $tmpTotalSettings = 0
            $tmpTotalSettings = $tmpUserStatsSelection.group.Settings.count

            $statString = "TotalPolicyAreas: {0}<br>TotalSettings: {1}" -f $tmpTotalAreas, $tmpTotalSettings

            if ([string]::IsNullOrEmpty($group.group[0].PolicyScopeDisplay)) 
            {
                $areaTitleString = '👤 {0}: Unknown'
            }
            else 
            {
                $areaTitleString = '👤 {0}: {1}' -f $group.Name, $group.group[0].PolicyScopeDisplay
            }
        }
        
        $htmlBody += "<div class='group-container'>"
        $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
        $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
        $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
        $htmlBody += "</div>"
        $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
        $htmlBody += "<div class='collapsible-content'>"
        
        $i = 0
        foreach ($policy in ($group.Group | Sort-Object -Property PolicyAreaName)) 
        {
            if ($i -gt 0) 
            {
                $htmlBody += "<br><br>"
            }

            $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>" 
            $htmlBody += "<button class='toggle-button-inner' onclick='toggleContent(this)'>Hide</button>" 
            $htmlBody += "<h2 class='policy-area-title'>PolicyArea: $($policy.PolicyAreaName)</h2>"
            $htmlBody += "</div>" 
            $htmlBody += "<div class='collapsible-content'>" 
            $htmlBody += "<table style='margin-bottom: 10px; width: 100%; border-collapse: collapse; table-layout: fixed;'>"
            $htmlBody += "<tr><td style='font-weight: bold; width: 400px;'>EnrollmentId</td><td>$($policy.EnrollmentId) ➡️ $($policy.EnrollmentProvider)</td><td style='width: 150px;'></td><td style='width: 200px;'></td></tr>"
            $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold; width: 400px;'>Setting ⚙️</th><th>Value</th><th style='width: 150px;'>DefaultValue</th><th style='width: 200px;'>WinningProvider</th></tr>"

            foreach ($settings in $policy.Settings) 
            {
                $settingspath = 'Path or DLL of the setting: "{0}"' -f $settings.Metadata.RedirectionPath

                if ($settings.WinningProvider -eq 'Not set' -or [string]::IsNullOrEmpty($settings.WinningProvider)) 
                {
                    $winningProviderString = $policy.EnrollmentProvider
                } 
                else 
                {
                    $tmpValue = $script:enrollmentProviderIDs[$settings.WinningProvider]
                    if ($tmpValue) 
                    {
                        $winningProviderString = $tmpValue
                    }
                    else 
                    {
                        $winningProviderString = $settings.WinningProvider
                    }
                }

                if ($winningProviderString.Trim() -ne $policy.EnrollmentProvider.Trim()) 
                {
                    $winningProviderString = "ℹ️ $winningProviderString"
                } 

                $value = Invoke-EscapeHtmlText -Text ($settings.Value -replace '&quot;', '"')
                $defaultValue = $settings.Metadata.DefaultValue
                $htmlBody += "<tr><td class='setting-col'>$($settings.Name)</td><td title='$($settingspath)'>$value</td><td style='width: 150px;'>$defaultValue</td><td style='width: 200px;'>$winningProviderString</td></tr>"
            }

            $htmlBody += "</table>"
            $htmlBody += "</div>"  # Close collapsible-content
            $i++
        }
        $htmlBody += "</div>"  # Close collapsible-content
        $htmlBody += "</div>"  # Close group-container
    }

    return $htmlBody
}
#endregion


#region Get-EnterpriseApplicationHTMLTables
function Get-EnterpriseApplicationHTMLTables 
{
    param
    (
        [Parameter(Mandatory = $true)]
        [array]$GroupedPolicies
    )

    $htmlBody = ""

    $enterpriseAppGroup = $GroupedPolicies.Where({ $_.Name -eq 'EnterpriseDesktopAppManagement' })

    $areaTitleString = '📦 EnterpriseDesktopAppManagement'
    $statString = "TotalAppPolicies: {0}" -f $enterpriseAppGroup.Group.Count

    $htmlBody = ""
    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
    $htmlBody += "<div class='collapsible-content'>"

    foreach ($app in $enterpriseAppGroup.Group)
    {

        $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>" 
        $htmlBody += "<button class='toggle-button-inner' onclick='toggleContent(this)'>Hide</button>" 
        $htmlBody += "<h2 class='policy-area-title'>App: $($app.possibleAppName)</h2>"
        $htmlBody += "</div>" 
        $htmlBody += "<div class='collapsible-content'>" 
        $htmlBody += "<table style='margin-bottom: 10px; width: 100%; border-collapse: collapse;'>"

        # Let's exclude some properties that are not relevant for the report
        $excludedProperties = @('PossibleAppName','ActionType', 'AssignmentType', 'BITSJobId', 'JobStatusReport', 'PolicyScope', 'ServerAccountID', 'PackageId', 'LocURI', 'PackageType')

        foreach ($property in ($app.PSObject.Properties))
        {
            if ($property.Name -in $excludedProperties) 
            {
                continue
            }

            $value = Invoke-EscapeHtmlText -Text ($property.Value)
            $htmlBody += "<tr><td style='font-weight: bold; width: 400px;'>$($property.Name)</td><td>$value</td></tr>"
        }
        
        $htmlBody += "</table>"
        $htmlBody += "</div>"  # Close collapsible-content
        $htmlBody += "<br>"
    }
    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody
}
#endregion


#region Get-ResourceHTMLTables
Function Get-ResourceHTMLTables
{
    param
    (
        [Parameter(Mandatory = $true)]
        [array]$GroupedPolicies
    )

    # Does not make sense when we use XML data from a different system. 
    # But does also not harm, because the report will simply not be able to match a SID to a username.
    $userInfoHash = Get-LocalUserInfo

    $resourcePolicies = $GroupedPolicies.Where({ $_.Name -eq 'Resource' }) 
    $groupedResources = $resourcePolicies.group | Group-Object -Property ResourceType, EnrollmentId 
    
    $areaTitleString = '🌐 Resources'
    $statString = "TotalResources: {0}" -f $groupedResources.Group.Count

    $htmlBody = ""
    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
    $htmlBody += "<div class='collapsible-content'>"

    foreach ($resourceEntry in ($groupedResources | Sort-Object -Property Name -Descending)) 
    {
        # Split the ResourceType, EnrollmentId from a single string
        # The format is "EResourceType, EnrollmentId"
        $tmpSplitVar = $resourceEntry.Name -split ',' # 0 = ResourceType, 1 = EnrollmentId

        $tmpResourceType = $tmpSplitVar[0].ToString().Trim()
        $tmpEnrollmentId = $tmpSplitVar[1].ToString().Trim()
        $enrollmentIdString = '{0} ➡️ {1}' -f $tmpEnrollmentId, ($resourceEntry.Group[0].ProviderID)

        $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>" 
        $htmlBody += "<button class='toggle-button-inner' onclick='toggleContent(this)'>Hide</button>" 
        $htmlBody += "<h2 class='policy-area-title'>ResourceType: $($tmpResourceType)</h2>"
        $htmlBody += "</div>" 
        $htmlBody += "<div class='collapsible-content'>" 
        $htmlBody += "<table style='margin-bottom: 10px; width: 100%; border-collapse: collapse; table-layout: fixed;'>"
        #$htmlBody += "<tr><td style='font-weight: bold;'>EnrollmentId</td><td colspan='5'>$($enrollmentIdString)</td></tr>"

        if ($tmpResourceType -eq 'RootCATrustedCertificates')
        {
            $htmlBody += "<tr><td style='font-weight: bold;'>EnrollmentId</td><td colspan='5'>$($enrollmentIdString)</td></tr>"
            $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold;'>ResourceTarget ⚙️</th><th>CertStore</th><th>Thumbprint</th><th>IssuedTo</th><th>Issuer</th><th>ExpiresIn</th></tr>"
        }
        elseif ($tmpResourceType -eq 'Firewall') 
        {
            $htmlBody += "<tr><td style='font-weight: bold;'>EnrollmentId</td><td colspan='3'>$($enrollmentIdString)</td></tr>"
            $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold;'>ResourceTarget ⚙️</th><th>Resource</th><th>Name</th><th>Value</th></tr>"
        }
        else 
        {
            $htmlBody += "<tr><td style='font-weight: bold; width: 500px;'>EnrollmentId</td><td>$($enrollmentIdString)</td></tr>"
            $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold; width: 500px;'>ResourceTarget ⚙️</th><th>Resource</th></tr>"
        }

        foreach ($resource in $resourceEntry.Group) 
        {
            
            if ($resource.ResourceTarget -eq 'Device') 
            {
                $resourceTargetString = '💻 Device'
            } 
            else 
            {
                $userName = $userInfoHash[$resource.ResourceTarget]
                if ([string]::IsNullOrEmpty($userName))
                {
                    $resourceTargetString = '👤 {0} - Unknown' -f ($resource.ResourceTarget)
                }
                else
                {
                    $resourceTargetString = '👤 {0} - {1}' -f ($resource.ResourceTarget), $userName
                }
            }

            # If the resource is a certificate, we need to display the certificate details
            if ($tmpResourceType -eq 'RootCATrustedCertificates')
            {
                # If the resource is a certificate, we can display the certificate details
                $tmpExpireDays = $resource.ResourceData.ExpireDays
                try 
                {
                    if ([int]$resource.ResourceData.ExpireDays -le 0)
                    {
                        $tmpExpireDays = '⚠️ {0}' -f $resource.ResourceData.ExpireDays   
                    }
                }
                catch {}

                $htmlBody += "<tr><td class='setting-col'>$($resourceTargetString)</td>"
                $htmlBody += "<td>$($resource.ResourceData.CertStore)</td>"
                $htmlBody += "<td>$($resource.ResourceData.Thumbprint)</td>"
                $htmlBody += "<td>$($resource.ResourceData.IssuedTo)</td>"
                $htmlBody += "<td>$($resource.ResourceData.Issuer)</td>"
                $htmlBody += "<td>$($tmpExpireDays)</td>"
                $htmlBody += "</tr>"

            }
            elseif ($tmpResourceType -eq 'Firewall') 
            {
                # If the resource is a firewall setting, we can try to display the firewall setting details
                $tmpName = ''
                $tmpFirewallSetting = ''

                $tmpSplit = $resource.ResourceName -split '\/'
                try 
                {
                    $tmpFirewallSetting = Get-MDMFirewallSetting -Topic ($tmpSplit[-2]) -SettingName ($tmpSplit[-1])
                }
                catch 
                {
                    $tmpFirewallSetting = $resource.ResourceName
                }
                 
                if ($resource.ResourceName -match 'FirewallRules')
                {
                    $tmpName = $tmpFirewallSetting -replace '.*\|Name=([^|]+)\|.*', '$1'
                }
                else 
                {
                    $tmpName = ($tmpSplit[-1])
                }

                $tmpResourceName = '{0}\{1}' -f ($tmpSplit[-2]), ($tmpSplit[-1])

                $htmlBody += "<tr><td class='setting-col'>$($resourceTargetString)</td>"
                $htmlBody += "<td>$($tmpResourceName)</td>"
                $htmlBody += "<td>$($tmpName)</td>"
                $htmlBody += "<td>$($tmpFirewallSetting)</td>"
                $htmlBody += "</tr>"
            }
            else 
            {
                # If the is an Office installation, we can get the install parameters from registry to display them in the report
                $tmpResourceName = $resource.ResourceName
                
                if ($tmpResourceName -match 'MSFT/Office/Installation')
                {
                    $officeResult = try{Get-IntuneOfficeInstallParams -ID ($tmpResourceName | Split-Path -Leaf)}catch{}
                    if ($officeResult)
                    {
                        # Escape the resource name to prevent the resource name from breaking our HTML
                        $officeResultEscaped = Invoke-EscapeHtmlText -Text ($officeResult)   
                        # We want to display the resource name and the office result in a single cell
                        $resourceName = '{0}<br><br>{1}' -f $tmpResourceName, $officeResultEscaped
                    }
                    else 
                    {
                        # Escape the resource name to prevent the resource name from breaking our HTML
                        $resourceName = Invoke-EscapeHtmlText -Text ($tmpResourceName)
                    }
                }
                else
                {
                    # Escape the resource name to prevent the resource name from breaking our HTML
                    $resourceName = Invoke-EscapeHtmlText -Text ($tmpResourceName)
                }

                $htmlBody += "<tr><td class='setting-col'>$($resourceTargetString)</td><td>$resourceName</td></tr>"
            }
        }
        
        $htmlBody += "</table>"
        $htmlBody += "</div>"
        $htmlBody += "<br>"

    }
    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody
}
#endregion


#region Get-IntuneWin32AppTables
Function Get-IntuneWin32AppTables
{
    $win32Apps = Get-IntuneWin32AppPolicies -LogPath $script:MDMDiagReportPathVariable

    $htmlBody = ""

    $areaTitleString = '🪟 Win32Apps'
    $statString = "TotalWin32AppPolicies: {0}" -f $win32Apps.Count

    $htmlBody = ""
    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
    $htmlBody += "<div class='collapsible-content'>"

    $excludedProperties = @('PolicyScope', 'ServerAccountID', 'PackageId')

    foreach ($app in $win32Apps) 
    {
        $htmlBody += "<div class='app-container'>"
        $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>" 
        $htmlBody += "<button class='toggle-button-inner' onclick='toggleContent(this)'>Hide</button>" 
        $htmlBody += "<h2 class='policy-area-title'>Win32App: $($app.Name)</h2>"
        $htmlBody += "</div>" 
        $htmlBody += "<div class='collapsible-content'>" 
        $htmlBody += "<table>"
        foreach ($property in ($app.PSObject.Properties | Sort-Object -Property Name | Where-Object { $_.Name -notin $excludedProperties })) 
        {
            # Lets format the AppState property to be a list in html
            $propertyValue = ''

            # Properties we will use some special formatting for to make the easier to read.
            switch ($property.Name) 
            {
                'AppState' 
                {  
                    if ([string]::IsNullOrEmpty($property.Value))
                    {
                        $propertyValue = "No app state found"
                    }
                    else 
                    {
                        $propertyValue = ConvertTo-HTMLTableFromArray -InputList ($property.Value) -ErrorAction SilentlyContinue
                        if ([string]::IsNullOrEmpty($propertyValue)) 
                        {
                            # Fallback to the original value if the conversion fails or is empty
                            $propertyValue = $property.Value
                        }
                    }                   
                }

                'DetectionRule'
                {
                    try 
                    {
                        [array]$tmpJsonString = $property.Value | ConvertFrom-Json -ErrorAction Stop
                        Foreach($item in $tmpJsonString)
                        {
                            $item.DetectionText = $item.DetectionText | ConvertFrom-Json # could be done with -depth parameter, but not in posh 5.1 
                            $propertyValue += ConvertFrom-ObjectToCustomHtmlTable -InputObjectList $item.DetectionText  
                        }
                    }
                    catch 
                    {
                        # In case of an error we will just use the original string
                        $propertyValue = $property.Value
                    }                    
                }

                'RequirementRules'
                {
                    try 
                    {
                        [array]$tmpJsonString = $property.Value | ConvertFrom-Json -ErrorAction Stop
                        Foreach($item in $tmpJsonString)
                        {
                            $propertyValue += ConvertFrom-ObjectToCustomHtmlTable -InputObjectList $item
                        }
                    }
                    catch 
                    {
                        # In case of an error we will just use the original string
                        $propertyValue = $property.Value
                    }                   
                }

                'ExtendedRequirementRules'
                {
                    try 
                    {
                        [array]$tmpJsonString = $property.Value | ConvertFrom-Json -ErrorAction Stop
                        Foreach($item in $tmpJsonString)
                        {
                            $item.RequirementText = $item.RequirementText | ConvertFrom-Json # could be done with -depth parameter, but not in posh 5.1 
                            $propertyValue += ConvertFrom-ObjectToCustomHtmlTable -InputObjectList $item.RequirementText
                        }
                    }
                    catch 
                    {
                        # In case of an error we will just use the original string
                        $propertyValue = $property.Value
                    }                   
                }

                # script block detection to account for multiple properties
                { $_ -in @('InstallEx','ReturnCodes','InstallerData')}
                {
                    # Some properties we should be able to convert to json and make them easier to read in that format
                    try 
                    {
                        # Converstion from unformatted json to object and from object to formatted json
                        $propertyValue = '<pre>{0}</pre>' -f ($property.Value | ConvertFrom-Json -ErrorAction Stop | ConvertTo-Json -ErrorAction Stop )    
                    }
                    catch 
                    {
                        $propertyValue = $property.Value
                    }                    
                }

                # script block detection to account for multiple properties
                { $_ -in @('RebootEx','StartDeadlineEx')}
                {
                    try 
                    {
                        # Conversion from unformatted object to formatted json
                        $propertyValue = '<pre>{0}</pre>' -f ($property.Value | ConvertTo-Json -ErrorAction Stop )
                    }
                    catch 
                    {
                        $propertyValue = $property.Value
                    }
                }
                Default 
                {
                    $propertyValue = $property.Value               
                }
            }
            
            $htmlBody += "<tr><td style='font-weight: bold; width: 300px;'>$($property.Name)</td><td>$($propertyValue)</td></tr>"
        }
        $htmlBody += "</table>"
        $htmlBody += "</div>"  # Close collapsible-content
        $htmlBody += "<br>"
    }
    
    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody
}
#endregion


#region Get-DeviceInfoHTMLTables
Function Get-DeviceInfoHTMLTables
{
    param
    (
        [Parameter(Mandatory = $true)]
        [array]$GroupedPolicies
    )

    $htmlBody = ""

    $deviceInfoData = $GroupedPolicies.Where({ $_.Name -eq 'DeviceInfo' }) 

    # Set the area title string based on the DeviceName
    # If the DeviceName is empty or null, set it to 'Unknown'
    if ([string]::IsNullOrEmpty($deviceInfoData.group[0].DeviceName)) 
    {
        $areaTitleString = '💻 Unknown'
    }
    else 
    {
        $areaTitleString = "💻 $($deviceInfoData.group[0].DeviceName)"
    }

    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>DeviceInfo: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<div class='collapsible-content'>"

    foreach ($device in $deviceInfoData.group) 
    {
        $htmlBody += "<table>"
        $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold; width: 300px;'>Property ⚙️</th><th>Value</th></tr>"

        foreach ($property in ($device.PSObject.Properties)) 
        {
            #skip properties that are not relevant for the report
            if ($property.Name -in @('PolicyScope', 'DeviceName')) 
            {
                continue
            }
            $htmlBody += "<tr><td style='font-weight: bold; width: 300px;'>$($property.Name)</td><td>$($property.Value)</td></tr>"
        }
        $htmlBody += "</table>"
        $htmlBody += "<br>"
    }

    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody
}
#endregion


#region Get-DeviceInfoHTMLTables
Function Get-LAPSHTMLTables
{
    param
    (
        [Parameter(Mandatory = $true)]
        [array]$GroupedPolicies
    )

    $infoData = $GroupedPolicies.Where({ $_.Name -eq 'LAPS' }) 

    $areaTitleString = "🔑 Local Admin Password Solution (LAPS)"

    if ($infoData) 
    {
        $statString = "LAPS policy: 1"
    }
    else 
    {
        $statString = "LAPS policy: 0"
    }
    
    $htmlBody = "" 
    $htmlBody += "<div class='group-container'>"
    $htmlBody += "<div style='display: flex; align-items: center; gap: 10px;'>"
    $htmlBody += "<button class='toggle-button' onclick='toggleContent(this)'>Hide</button>"
    $htmlBody += "<h2>PolicyScope: <span class='policy-area-title'>$areaTitleString</span></h2>"
    $htmlBody += "</div>"
    $htmlBody += "<p style='font-size: 13px;'>$statString</p>"
    $htmlBody += "<div class='collapsible-content'>"
    

    foreach ($item in $infoData.group) 
    {
        $htmlBody += "<table>"
        $htmlBody += "<tr style='border-top: 3px solid #ddd;'><th style='font-weight: bold; width: 300px;'>Setting ⚙️</th><th>Value</th></tr>"
        foreach ($property in ($item.PSObject.Properties)) 
        {
            #skip properties that are not relevant for the report
            if ($property.Name -in @('PolicyScope')) 
            {
                continue
            }
            $htmlBody += "<tr><td style='font-weight: bold; width: 300px;'>$($property.Name)</td><td>$($property.Value)</td></tr>"
        }
        $htmlBody += "</table>"
        $htmlBody += "<br>"
    }

    $htmlBody += "</div>"  # Close collapsible-content
    $htmlBody += "</div>"  # Close group-container
    return $htmlBody
}
#endregion


#region Convert-IntunePoliciesToHtml
function Convert-IntunePoliciesToHtml 
{
    param 
    (
        [Parameter(Mandatory=$false)]
        [string]$OutputPath,

        [Parameter(Mandatory=$false)]
        [array]$Policies,

        [string]$Title = "Intune Policy Report"
    )

    if ([string]::IsNullOrEmpty($script:MDMDiagReportPathVariable)) 
    {
        $headerSubText = "Generated locally running on $($env:COMPUTERNAME) on: 📅 $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    }
    else 
    {
        $headerSubText = "Generated from captured MDM Diagnostics Report on: 📅 $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    }

$htmlHeader = @"
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>$Title</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 14px; }
        h1 { font-size: 24px; color: #2E6DA4; }
        h2 { font-size: 18px; color: #444; margin-top: 10px; }

        .toggle-button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 5px 10px;
            margin-bottom: 10px;
            cursor: pointer;
            border-radius: 4px;
            width: 90px;           /* Fixed width for consistent size */
            text-align: center;     /* Center the text */
            box-sizing: border-box; /* Ensure padding is included in width */
        }

        .toggle-button-inner {
            background-color: #525e6bff;
            color: white;
            border: none;
            padding: 5px 10px;
            margin-bottom: 10px;
            cursor: pointer;
            border-radius: 4px;
            width: 70px;           /* Fixed width for consistent size */
            text-align: center;     /* Center the text */
            box-sizing: border-box; /* Ensure padding is included in width */
        }

        .collapsible-content {
            display: block;
            margin-top: 10px;
        }

        .group-container {
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            padding: 15px;
            margin-bottom: 30px;
            border-radius: 6px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.05);
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 20px;
            table-layout: fixed;
            border: 3px solid #ddd;
            font-size: 13px; 
        }

        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            word-wrap: break-word;
            text-align: left;
            vertical-align: top;
            font-size: 13px; 
        }
       
        th { background-color: #f2f2f2; text-align: left; }
        tr:nth-child(even) { background-color: #f9f9f9; }

        th.resource-col, td.resource-col { width: 100px; }
        th { background-color: #f2f2f2; text-align: left; }
        tr:nth-child(even) { background-color: #f9f9f9; }

        .policy-area-title {
            color: #2E6DA4;
        }
        
        .nested-table {
            border: none !important;
            border-collapse: collapse;
            width: 100%;
            table-layout: fixed;
            font-size: 13px;
        }

        .nested-table th, .nested-table td {
            outline: 1px solid #ddd;
            border: none;
            padding: 8px;
            word-wrap: break-word;
            text-align: left;
            vertical-align: top;
        }

        .nested-table td:first-child {
            width: 200px;
        }


    </style>
    <script>
        
        function toggleContent(button) {
            // Try to find the next sibling collapsible content
            let content = button.parentElement.nextElementSibling;

            // If not found, fall back to the closest .group-container's .collapsible-content
            if (!content || !content.classList.contains('collapsible-content')) {
                const groupContainer = button.closest('.group-container');
                content = groupContainer ? groupContainer.querySelector('.collapsible-content') : null;
            }

            if (!content) return;

            const isVisible = window.getComputedStyle(content).display !== "none";
            content.style.display = isVisible ? "none" : "block";
            button.textContent = isVisible ? "Show" : "Hide";
        }

        function toggleAll() {
            const contents = document.querySelectorAll('.collapsible-content');
            const buttons = document.querySelectorAll('.toggle-button:not(#toggleAllBtn)');
            const toggleAllBtn = document.getElementById('toggleAllBtn');
            const shouldCollapse = toggleAllBtn.textContent === 'Collapse All';

            contents.forEach((content, index) => {
                    content.style.display = shouldCollapse ? 'none' : 'block';
                if (buttons[index]) {
                buttons[index].textContent = shouldCollapse ? 'Show' : 'Hide';
            }
        });

        toggleAllBtn.textContent = shouldCollapse ? 'Expand All' : 'Collapse All';
        }


    </script>
</head>
<body>
    <h1>$Title ⚙️</h1>
    <p>$headerSubText</p>
    <p>This report contains detailed information about Intune policies applied to devices and users.</p>
    <button class='toggle-button' onclick='toggleAll()' id='toggleAllBtn'>Collapse All</button>
"@


    $htmlFooter = "</body></html>"
    $htmlBody = ""
 
    $grouped = $Policies | Group-Object -Property PolicyScope

    $htmlBody += Get-DeviceInfoHTMLTables -GroupedPolicies $grouped

    $htmlBody += Get-DeviceAndUserHTMLTables -GroupedPolicies $grouped

    $htmlBody += Get-EnterpriseApplicationHTMLTables -GroupedPolicies $grouped

    $htmlBody += Get-ResourceHTMLTables -GroupedPolicies $grouped

    $htmlBody += Get-LAPSHTMLTables -GroupedPolicies $grouped 

    $htmlBody += Get-IntuneWin32AppTables

    $fullHtml = $htmlHeader + $htmlBody + $htmlFooter

    Set-Content -Path $OutputPath -Value $fullHtml -Encoding UTF8
}
#endregion


#region Format-StringToXml
function Format-StringToXml 
{
    param 
    (
        [string]$XmlString
    )

    # Wrap in a root element to ensure valid XML
    $wrappedXml = "<root>$XmlString</root>"

    try {
        [xml]$xml = $wrappedXml
    } catch {
        Write-Host "Invalid XML format" -ForegroundColor Yellow
        return $XmlString
    }

    $formattedXml = ""

    if ($xml.root.enabled) {
        $formattedXml += "&lt;enabled/&gt;<br>"
    }

    foreach ($node in $xml.root.data) {
        $id = $node.id
        $value = $node.value
        $formattedXml += "&nbsp;&nbsp;&lt;data id='$id' value='$value'/&gt;<br>"
    }

    return "<pre>$formattedXml</pre>"
}
#endregion



#region MAIN SCRIPT EXECUTION
#$userInfoHash = Get-LocalUserInfo
# Lets cleanup any previous Intune report data
Invoke-IntuneReportDataCleanup -CleanUpDays $CleanUpDays

# Making the MDMDiagReportPath a script variable to be used in other functions
$script:MDMDiagReportPathVariable = $MDMDiagReportPath

$MDMDiagReportXml = Get-IntunePolicyDataFromXML -MDMDiagReportPath $MDMDiagReportPath
$MDMDiagReportHTMLPath = $MDMDiagReportXml.FileFullName -replace '.xml', '.html'

$script:MDMDiagHTMLReportPathVariable = $MDMDiagReportHTMLPath 

$script:enrollmentProviderIDs = Get-EnrollmentProviderIDs -MDMData $MDMDiagReportXml.XMlFileData

# Initialize a list to hold all Intune policies
$IntunePolicyList = [System.Collections.Generic.List[pscustomobject]]::new()

Get-IntunePolicySystemInfo -HtmlReportPath $MDMDiagReportHTMLPath | ForEach-Object {
    $IntunePolicyList.Add($_)
}

Get-IntuneDeviceAndUserPolicies -MDMData $MDMDiagReportXml.XMlFileData | ForEach-Object {
    $IntunePolicyList.Add($_)
}

Get-IntuneMSIPolicies -MDMData $MDMDiagReportXml.XMlFileData | ForEach-Object {
    $IntunePolicyList.Add($_)
}

Get-IntuneResourcePolicies -MDMData $MDMDiagReportXml.XMlFileData | ForEach-Object {
    $IntunePolicyList.Add($_)
}

Get-IntunePoliyLAPSData -MDMData $MDMDiagReportXml.XMlFileData | ForEach-Object {
    $IntunePolicyList.Add($_)
}

# name of the file to save the HTML report
$outFile = '{0}\IntunePolicyReport.html' -f (Split-Path -Path $MDMDiagReportHTMLPath -Parent)

# Convert the policies to HTML and save to the specified output path
Convert-IntunePoliciesToHtml -OutputPath $outFile -Policies $IntunePolicyList -Title "Intune Policy Report"

# Open the generated HTML report in Microsoft Edge
Start-Process "msedge.exe" -ArgumentList $outFile

